/*
 * ====================================================================
 * Project:     openmdx, http://www.openmdx.org/
 * Name:        $Id: Calendar_1.jt,v 1.4 2007/06/04 12:57:33 hburger Exp $
 * Description: Calendar_1 class
 * Revision:    $Revision: 1.4 $
 * Owner:       OMEX AG, Switzerland, http://www.omex.ch
 * Date:        $Date: 2007/06/04 12:57:33 $
 * ====================================================================
 *
 * This software is published under the BSD license as listed below.
 * 
 * Copyright (c) 2004-2007, OMEX AG, Switzerland
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * 
 * * Neither the name of the openMDX team nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * ------------------
 * 
 * This product includes software developed by other organizations as
 * listed in the NOTICE file.
 */
package org.openmdx.test.compatibility.base.dataprovider.layer.model;

import java.util.GregorianCalendar;

import javax.jdo.PersistenceManager;
import javax.jdo.Transaction;

import org.openmdx.base.accessor.jmi.cci.RefPackage_1_1;
import org.openmdx.base.accessor.jmi.spi.RefRootPackage_1;
import org.openmdx.base.exception.ServiceException;
import org.openmdx.compatibility.base.dataprovider.cci.DataproviderRequest;
import org.openmdx.compatibility.base.dataprovider.cci.ServiceHeader;
import org.openmdx.compatibility.base.dataprovider.layer.model.ObjectView_1;
import org.openmdx.compatibility.base.naming.Path;

#if defined(BEFORE16)
import org.openmdx.base.cci.Authority;
import org.openmdx.base.cci.Provider;
import org.openmdx.base.cci.Segment;
import org.openmdx.test.calendar1.cci.Calendar;
import org.openmdx.test.calendar1.cci.Day;
import org.openmdx.test.calendar1.cci.Year;
import org.openmdx.test.calendar1.jmi.Calendar1Package;
#else
import org.openmdx.base.jmi1.Authority;
import org.openmdx.base.jmi1.Provider;
import org.openmdx.base.jmi1.Segment;
import org.openmdx.test.calendar1.jmi1.Calendar;
import org.openmdx.test.calendar1.jmi1.Day;
import org.openmdx.test.calendar1.jmi1.Year;
import org.openmdx.test.calendar1.jmi1.Calendar1Package;
#endif

/**
 * Calendar_1 class
 */
public class Calendar_1
  extends ObjectView_1 
{
	
	
	/* (non-Javadoc)
	 * @see org.openmdx.compatibility.base.dataprovider.layer.model.ObjectView_1#prolog(org.openmdx.compatibility.base.dataprovider.cci.ServiceHeader, org.openmdx.compatibility.base.dataprovider.cci.DataproviderRequest[])
	 */
	public void prolog(ServiceHeader header, DataproviderRequest[] requests) throws ServiceException {
		super.prolog(header, requests);
		this.clearStorage();
	}

	//-------------------------------------------------------------------------
    private PersistenceManager prepareCalendarPkg(
    ) throws ServiceException {
        RefPackage_1_1 volatileRootPkg = new RefRootPackage_1(
            this.getVolatileObjectFactory(),
            false
        );
        this.calendarPkg = (Calendar1Package)volatileRootPkg.refPackage(
            "org:openmdx:test:calendar1"
        );           
        this.calendarAuthority = (Authority) volatileRootPkg.refPersistenceManager().getObjectById(
            Authority.class,
            Calendar1Package.AUTHORITY_XRI
        );
        return volatileRootPkg.refPersistenceManager();
    }

	//-------------------------------------------------------------------------
	private Calendar prepareCalendar(
    	Path identity
  	) throws ServiceException {
        Provider provider = (Provider)this.calendarAuthority.getProvider(identity.get(2));
  		Calendar calendar = (Calendar)provider.getSegment("Gregorian");
	  	if(calendar == null) {
  			calendar = this.calendarPkg.getCalendar().createCalendar();
	  		provider.addSegment(
	      		"Gregorian",
				calendar
			);
  		}
  		return calendar;
	}
	
	//-------------------------------------------------------------------------
	/**
	 * Prepare all years supported by this calendar
	 */
  	private Year prepareYears(
    	Path identity,
		int returnYear
  	) throws ServiceException {
  		Calendar calendar = this.prepareCalendar(identity.getParent()); 
  		// create years
	  	Year result = null; 
	  	for(int i = 1990; i < 2010; i++) {
	  		String yearId = i + "";
	    	Year year = calendar.getYear(yearId);
	    	if(year == null) {
	    		year = this.calendarPkg.getYear().createYear();
		    	calendar.addYear(
		        i + "",
						year
		      );
	    	}
	    	if(i == returnYear) {
	    		result = year;
	    	}
	  	}
	  	return result;
	}
  
	//-------------------------------------------------------------------------
  	private Year prepareYear(
    	Path identity
  	) throws ServiceException {
    	return this.prepareYears(
      		identity.getParent(),
			new Integer(identity.getBase()).intValue()
	  	);
  	}

	//-------------------------------------------------------------------------
  	/**
   	 * Preppare all days of the year specified by identity
   	 */
  	private void prepareDays(
    	Path identity
  	) throws ServiceException {
  		Year forYear = this.prepareYear(identity.getParent()); 
  		int year = new Integer(identity.getParent().getBase()).intValue();
  		java.util.Calendar calendar = new GregorianCalendar();
  		calendar.set(year, java.util.Calendar.JANUARY, 1);
  		while(calendar.get(java.util.Calendar.YEAR) == year) {
	  		String dayId = calendar.get(java.util.Calendar.DAY_OF_YEAR) + "";
	    	Day day = forYear.getDay(dayId); 
	      	if(day == null) {
	    		day = this.calendarPkg.getDay().createDay();
		    	day.setYear(calendar.get(java.util.Calendar.YEAR));
		    	day.setMonth(calendar.get(java.util.Calendar.MONTH));
		    	day.setDayOfMonth(calendar.get(java.util.Calendar.DAY_OF_MONTH));
		    	day.setDayOfWeek(calendar.get(java.util.Calendar.DAY_OF_WEEK));
		    	forYear.addDay(
		        	calendar.get(java.util.Calendar.DAY_OF_YEAR) + "",
					day
		      	);
		  		calendar.add(java.util.Calendar.DATE, 1);
	      	}
	  	}
	}

	//-------------------------------------------------------------------------
  	private void prepareDay(
    	Path identity
  	) throws ServiceException {
  		this.prepareDays(
      		identity.getParent()
	  	);
  	}
  
  	//-------------------------------------------------------------------------
  	protected void clearStorage(
  	) throws ServiceException {
        Transaction transaction = this.prepareCalendarPkg().currentTransaction();
        transaction.begin();
        Provider provider = (Provider)this.calendarAuthority.getProvider("Calendar");
        Segment segment = provider.getSegment("Gregorian");
        if(segment != null) segment.refDelete();
        try {
            transaction.commit();
        } catch(Exception e) {              
        }
  	}
  
  	//-------------------------------------------------------------------------
	protected void prepareContainer(
    	Path identity
  	) throws ServiceException {
		this.prepareCalendarPkg();
    	if(identity.isLike(new Path("xri:@openmdx:org.openmdx.test.calendar1/provider/Calendar/segment"))) {
      		this.prepareCalendar(identity);    	
    	}
    	if(identity.isLike(new Path("xri:@openmdx:org.openmdx.test.calendar1/provider/Calendar/segment/Gregorian/year"))) {
      		this.prepareYears(identity, -1);    	
    	} else if(identity.isLike(new Path("xri:@openmdx:org.openmdx.test.calendar1/provider/Calendar/segment/Gregorian/year/:*/day"))) {
      		this.prepareDays(identity);    	
    	}
	}

	//-------------------------------------------------------------------------
	protected void prepareObject(
    	Path identity
  	) throws ServiceException {
		this.prepareCalendarPkg();
    	if(identity.isLike(new Path("xri:@openmdx:org.openmdx.test.calendar1/provider/Calendar/segment/Gregorian"))) {
      		this.prepareCalendar(identity);    	
    	} else if(identity.isLike(new Path("xri:@openmdx:org.openmdx.test.calendar1/provider/Calendar/segment/Gregorian/year/:*"))) {
      		this.prepareYear(identity);    	
	    } else if(identity.isLike(new Path("xri:@openmdx:org.openmdx.test.calendar1/provider/Calendar/segment/Gregorian/year/:*/day/:*"))) {
      		this.prepareDay(identity);    	
    	}
	}
	
	//-------------------------------------------------------------------------
	// Variables
	//-------------------------------------------------------------------------
    private Calendar1Package calendarPkg = null;
    private Authority calendarAuthority = null;
	
}

