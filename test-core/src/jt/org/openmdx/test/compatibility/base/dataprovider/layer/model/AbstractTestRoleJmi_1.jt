/*
 * ====================================================================
 * Project:     openmdx, http://www.openmdx.org/
 * Name:        $Id: AbstractTestRoleJmi_1.jt,v 1.3 2007/06/04 12:57:46 hburger Exp $
 * Description: junit for Jmi and RoleObject_1
 * Revision:    $Revision: 1.3 $
 * Owner:       OMEX AG, Switzerland, http://www.omex.ch
 * Date:        $Date: 2007/06/04 12:57:46 $
 * ====================================================================
 *
 * This software is published under the BSD license as listed below.
 * 
 * Copyright (c) 2004-2007, OMEX AG, Switzerland
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * 
 * * Neither the name of the openMDX team nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * ------------------
 * 
 * This product includes software developed by other organizations as
 * listed in the NOTICE file.
 */
package org.openmdx.test.compatibility.base.dataprovider.layer.model;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;

import javax.jdo.PersistenceManager;
import javax.jdo.Transaction;
import javax.jmi.reflect.JmiException;

import junit.framework.TestCase;

import org.openmdx.application.log.AppLog;
import org.openmdx.base.accessor.generic.cci.ObjectFactory_1_0;
import org.openmdx.base.accessor.generic.view.Manager_1;
//import org.openmdx.base.accessor.jmi.cci.JmiServiceException;
import org.openmdx.base.accessor.jmi.cci.RefObject_1_0;
import org.openmdx.base.accessor.jmi.cci.RefPackage_1_1;
import org.openmdx.base.accessor.jmi.spi.RefRootPackage_1;
import org.openmdx.base.exception.ServiceException;
import org.openmdx.compatibility.application.dataprovider.transport.ejb.cci.Dataprovider_1ConnectionFactoryImpl;
import org.openmdx.compatibility.base.application.container.LightweightContainer_1;
import org.openmdx.compatibility.base.application.container.SimpleServiceLocator;
import org.openmdx.compatibility.base.collection.Container;
import org.openmdx.compatibility.base.dataprovider.cci.Dataprovider_1_0;
import org.openmdx.compatibility.base.dataprovider.cci.Orders;
import org.openmdx.compatibility.base.dataprovider.cci.RequestCollection;
import org.openmdx.compatibility.base.dataprovider.cci.ServiceHeader;
import org.openmdx.compatibility.base.dataprovider.layer.model.StopWatch_1;
import org.openmdx.compatibility.base.dataprovider.transport.adapter.Provider_1;
import org.openmdx.compatibility.base.dataprovider.transport.cci.Dataprovider_1_1Connection;
import org.openmdx.compatibility.base.dataprovider.transport.cci.Provider_1_0;
import org.openmdx.compatibility.base.dataprovider.transport.delegation.Connection_1;
import org.openmdx.compatibility.base.dataprovider.transport.webservices.Dataprovider_1Connection;
import org.openmdx.compatibility.base.naming.Path;
import org.openmdx.compatibility.base.time.SetupStopWatch;
import org.openmdx.compatibility.base.time.TreeStopWatch;
import org.openmdx.deployment1.accessor.basic.DeploymentConfiguration_1;
import org.openmdx.kernel.exception.BasicException;


#if defined(BEFORE16)
import org.openmdx.compatibility.role1.cci.Role;
import org.openmdx.test.compatibility.role1.cci.Customer;
import org.openmdx.test.compatibility.role1.cci.CustomerClass;
import org.openmdx.test.compatibility.role1.cci.Employee;
import org.openmdx.test.compatibility.role1.cci.EmployeeClass;
import org.openmdx.test.compatibility.role1.cci.EmployeeRoleType;
import org.openmdx.test.compatibility.role1.cci.EmployeeRoleTypeClass;
import org.openmdx.test.compatibility.role1.cci.Person;
import org.openmdx.test.compatibility.role1.cci.PersonClass;
import org.openmdx.test.compatibility.role1.cci.RoleAbstractRoot;
import org.openmdx.test.compatibility.role1.cci.RoleClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassD;
import org.openmdx.test.compatibility.role1.cci.RoleClassDClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassDRoleA;
import org.openmdx.test.compatibility.role1.cci.RoleClassDRoleAClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassDRoleARoleType;
import org.openmdx.test.compatibility.role1.cci.RoleClassDRoleARoleTypeClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassFree;
import org.openmdx.test.compatibility.role1.cci.RoleClassFreeClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleA;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleAClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleARoleA;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleARoleAClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleARoleARoleType;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleARoleARoleTypeClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleARoleType;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleARoleTypeClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleB;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleBClass;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleBRoleType;
import org.openmdx.test.compatibility.role1.cci.RoleClassRoleBRoleTypeClass;
import org.openmdx.test.compatibility.role1.cci.RoleNoRole;
import org.openmdx.test.compatibility.role1.cci.RoleNoRoleClass;
import org.openmdx.test.compatibility.role1.cci.RoleReferenceTest;
import org.openmdx.test.compatibility.role1.cci.Segment;
import org.openmdx.test.compatibility.role1.cci.SegmentClass;
import org.openmdx.test.compatibility.role1.jmi.Role1Package;
import org.openmdx.test.compatibility.role1.query.RoleAbstractRootQuery;
import org.openmdx.test.compatibility.role1.query.RoleClassQuery;
import org.openmdx.test.compatibility.role1.query.RoleClassRoleARoleAQuery;
import org.openmdx.test.compatibility.role1.query.RoleClassDRoleAQuery;
import org.openmdx.test.compatibility.role1.query.RoleClassRoleAQuery;
import org.openmdx.test.compatibility.role1.query.RoleClassFreeQuery;
#else
import org.openmdx.compatibility.role1.jmi1.Role;
import org.openmdx.test.compatibility.role1.jmi1.Customer;
import org.openmdx.test.compatibility.role1.jmi1.CustomerClass;
import org.openmdx.test.compatibility.role1.jmi1.Employee;
import org.openmdx.test.compatibility.role1.jmi1.EmployeeClass;
import org.openmdx.test.compatibility.role1.jmi1.EmployeeRoleType;
import org.openmdx.test.compatibility.role1.jmi1.EmployeeRoleTypeClass;
import org.openmdx.test.compatibility.role1.jmi1.Person;
import org.openmdx.test.compatibility.role1.jmi1.PersonClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleAbstractRoot;
import org.openmdx.test.compatibility.role1.jmi1.RoleClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassD;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassDClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassDRoleA;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassDRoleAClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassDRoleARoleType;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassDRoleARoleTypeClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassFree;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassFreeClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleA;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleAClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleARoleA;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleARoleAClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleARoleARoleType;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleARoleARoleTypeClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleARoleType;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleARoleTypeClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleB;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleBClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleBRoleType;
import org.openmdx.test.compatibility.role1.jmi1.RoleClassRoleBRoleTypeClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleNoRole;
import org.openmdx.test.compatibility.role1.jmi1.RoleNoRoleClass;
import org.openmdx.test.compatibility.role1.jmi1.RoleReferenceTest;
import org.openmdx.test.compatibility.role1.jmi1.Segment;
import org.openmdx.test.compatibility.role1.jmi1.SegmentClass;
import org.openmdx.test.compatibility.role1.jmi1.Role1Package;
import org.openmdx.test.compatibility.role1.cci2.RoleAbstractRootQuery;
import org.openmdx.test.compatibility.role1.cci2.RoleClassQuery;
import org.openmdx.test.compatibility.role1.cci2.RoleClassRoleARoleAQuery;
import org.openmdx.test.compatibility.role1.cci2.RoleClassDRoleAQuery;
import org.openmdx.test.compatibility.role1.cci2.RoleClassRoleAQuery;
import org.openmdx.test.compatibility.role1.cci2.RoleClassFreeQuery;
#endif

/**
 * junit to test Jmi access to a provider using RoleObject_1 plugin.
 */
public abstract class AbstractTestRoleJmi_1 extends TestCase {

  //---------------------------------------------------------------------------  
  /**
   * Constructor
   */
  protected AbstractTestRoleJmi_1(
    String name
  ) {
    super(name);
  }    
    
  //---------------------------------------------------------------------------    
  protected void setUp(
  ) throws Exception {  
    try {
        if(! deployed){
            System.out.println("Deploying...");
            DeploymentConfiguration_1.createInstance(
                new String[]{
                    "xri://+resource/org/openmdx/test/deployment.configuration.xml",
                    "xri://+resource/org/openmdx/test/compatibility/base/dataprovider/layer/model/rolejmi/deployment.configuration.xml"
                }
            );
            new LightweightContainer_1(
                "TestRoleJmi_1",
                CONNECTOR_DEPLOYMENT_UNITS,
                PROVIDER_DEPLOYMENT_UNITS
            );
            deployed = true;
      }
      
      String testName = ">>>> **** Start Test: " + this.getName();
      System.out.println(testName);
      AppLog.info(testName);
      AppLog.info("Start Test", this.getName());  
      SetupStopWatch.instance().start();

      // get connection
      Dataprovider_1_1Connection remoteConnection = Dataprovider_1ConnectionFactoryImpl.createGenericConnection(
          SimpleServiceLocator.getInitialContext().lookup("org/openmdx/test/managing/explorer")
      );

      // intercept webservice transport for testing
      connection =
//        new Dataprovider_1_0ConnectionImpl("http://localhost:8080/dataproviders/junits");
        new Dataprovider_1Connection(remoteConnection);
      
      // initial paths
      AbstractTestRoleJmi_1.rootSegment = new Path("xri:@openmdx:org.openmdx.test.compatibility.role1/provider/" + this.getName() + "/segment/Standard");          
    } catch(Exception e) {
      AppLog.error("exception", e);
      throw e;
    }
  }

  //---------------------------------------------------------------------------  
  protected void tearDown(
  ) {
    try {
      SetupStopWatch.instance().stop(this.getName(), SetupStopWatch.EXECUTION);
      String testName = "<<<< **** End Test: " + this.getName();            
      System.out.println(testName);
      AppLog.info(testName);
    }
    catch(Exception e) {
      System.out.println("error in deactivating");
    }
  }
  
  //---------------------------------------------------------------------------
  public void None(
  ) throws Exception {
    doAll();
  }  

  //---------------------------------------------------------------------------
  public void Jdbc(
  ) throws Exception {
    doAll();
  }  
  
  //---------------------------------------------------------------------------  
  private void doAll(
  ) throws Exception {
    testPerformance();
    testAggregationInRole();
    testDocu();
    testFindContinuation();
    testFindIteratingSorted();
    testMultipleQualifyingAttributes();
    testRoleInstancesInGroup();
    testRoleInstancesInSingleGroup();
    testRoleIteration();
    testRoleTypeAccess();
    testRoleTypeAccessById();
    testRoleTypesQualifyingAttribute();
  }
  
  //---------------------------------------------------------------------------  
  private void verifyException(
    BasicException e,
    int code,
    String description
  ) throws ServiceException {
    if(!assertException(e, code, description)) {
      AppLog.error("exception", e);
      throw new ServiceException(e);
    }
  }
  
  /**
   * @deprecated
   * @param e
   * @param code
   * @param description
   * @return
   */
  private boolean verifyException(
      Exception e,
      int code,
      String description
  ) {
      Throwable cause = e instanceof BasicException.Wrapper ? e : e.getCause();
      if(cause instanceof BasicException.Wrapper) {
          return assertException((BasicException.Wrapper)cause, code, description);
      } else {
          System.out.println(
              "cause should be a ServiceException.Wrapper but is " +
              (cause == null ? "null" : cause.getClass().getName())
          );
          return false;
      }
  }
  
  //---------------------------------------------------------------------------  
    private boolean isDuplicateException(
//      JmiServiceException je
        Exception je
    ) {
//      boolean duplicateEx = false;
//      if (je instanceof JmiServiceException ) {
//          JmiServiceException jse =  (JmiServiceException)je;
//          BasicException se = jse.getExceptionStack();
//          for (int i = 0; i < se.getExceptionStack().size()&& !duplicateEx; i++ ) {
//              duplicateEx =  
//                  ((BasicException)se.getExceptionStack().get(i))
//                      .getExceptionCode() == BasicException.Code.DUPLICATE;
//          }
//      }
//      
//      return duplicateEx;
        BasicException se = new ServiceException(je).getExceptionStack();
        for (int i = 0; i < se.getExceptionStack().size(); i++ ) {
            if(  
                ((BasicException)se.getExceptionStack().get(i))
                    .getExceptionCode() == BasicException.Code.DUPLICATE
            ) {
            	return true;
            }
        }
        return false;
    }
    
    //---------------------------------------------------------------------------  
      private boolean isNotFoundException(
//        JmiException je
          Exception je
      ) {
//        boolean duplicateEx = false;
//        if (je instanceof JmiServiceException ) {
//            JmiServiceException jse =  (JmiServiceException)je;
//            duplicateEx =  
//            ((BasicException)jse.getExceptionStack().getExceptionStack().get(0))
//                .getExceptionCode() == BasicException.Code.NOT_FOUND;
//        }
//      
//        return duplicateEx;
          return ((BasicException)ServiceException.toServiceException(je).getExceptionStack().getExceptionStack().get(0))
                .getExceptionCode() == BasicException.Code.NOT_FOUND;
      }
    
    
  //---------------------------------------------------------------------------  
  private boolean assertException(
    BasicException e,
    int code,
    String description
  ) {
    BasicException initial = (BasicException)e.getExceptionStack().get(0);
    if(initial.getExceptionCode() != code) {
      System.out.println("exception code should be " + code + " but is " + initial.getExceptionCode());
      return false;
    }
    else if(
      (description != null) &&
      !"".equals(description) && 
      !initial.getDescription().equals(description)
    ) {
      System.out.println("description should be " + description + " but is " + initial.getDescription());
      return false;
    }
    else {
      return true;
    }
  }

  /**
   * @deprecated
   * 
   * @param e
   * @param code
   * @param description
   * @return
   */
  private boolean assertException(
      BasicException.Wrapper e,
      int code,
      String description
  ) {
      return assertException(e.getExceptionStack(), code, description);
  }

  /** 
   * helper method for creating Package.
   * 
   * @param header        header for channel
   * @param dataprovider  dataprovider for channel
   * @return role1Package  initialized package for channel
   * @throws Exception
   */
  protected Role1Package createRole1Package(
      ServiceHeader header,
      Dataprovider_1_0 dataprovider
  ) throws Exception {
      
      Provider_1_0 provider = new Provider_1(
          new RequestCollection(
              header,
              dataprovider
          ),
          false
      );
      
      ObjectFactory_1_0 manager = new Manager_1(
        new Connection_1(
            provider,
            false
        )
      );
      
      // create package
      //System.out.println("activating model...");
      javax.jmi.reflect.RefPackage rootPkg = new RefRootPackage_1(
        manager, null, null, false
      );
      Role1Package pkg = (Role1Package)rootPkg.refPackage("org:openmdx:test:compatibility:role1");
      return pkg;
  }
  
  
//private void showException(Throwable t) {
//    if (t instanceof JmiServiceException) {
//        JmiServiceException je = (JmiServiceException) t;
//        System.out.println("JmiServiceException: " + je.getMessage());
//        showException(je.getExceptionStack());
//    }
//    else if (t instanceof ServiceException) {
//        ServiceException se = (ServiceException) t;
//        System.out.println("ServiceException: " + se.getMessage());
//        System.out.println(se.toString());
//    }
//    else if (t instanceof RuntimeServiceException){
//        RuntimeServiceException se = (RuntimeServiceException) t;
//        System.out.println("RuntimeServiceException: " + se.getMessage());
//        showException(se.getExceptionStack());
//    }
//    else {
//        t.getMessage();
//        t.printStackTrace();
//    }
//}

  private void showException(Exception t) {
      ServiceException se = new ServiceException(t).log();
      System.err.println(se.getMessage());
      se.getCause().printStackTrace();
  }

  
  /**
   * remove all RoleClass objects from the segment.
   * 
   * @param numberOfObjects
   * @throws Exception
   */
  private void removeRoleClassesFromSegment(
  ) throws Exception {
        System.out.println(" removeRoleClassesFromSegment ");
        
        Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
        Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
        
        SegmentClass modelSegmentClass = pkg.getSegment();
        Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
        Collection allObjects = modelSegment.getRoleAbstractRoot();

        HashSet deletedObjects = new HashSet();
        
        unitOfWork.begin();
        System.err.println("After begin " + modelSegment.getRoleAbstractRoot().size());
        for (Iterator all = allObjects.iterator(); all.hasNext(); ) {
            RoleAbstractRoot roleAbstractRoot = (RoleAbstractRoot) all.next();
            // System.out.println("iterating: " + roleAbstractRoot.refGetPath() + " " + roleAbstractRoot.getIdentity());
            if (roleAbstractRoot instanceof RoleClass) {
                RoleClass roleClass = (RoleClass) roleAbstractRoot;

                if (deletedObjects.add(roleClass.getIdentity())) {
                    // System.out.println("deleting : " + roleClass.refGetPath() + " " + roleClass.getIdentity());
                    
                    all.remove();
                }
            }
        }
        System.err.println("Before completion " + modelSegment.getRoleAbstractRoot().size());
        unitOfWork.commit();
        System.err.println("After completion " + modelSegment.getRoleAbstractRoot().size());
        
        
        allObjects = modelSegment.getRoleAbstractRoot();
        
        assertEquals(
            "Still objects in the segment after deleting all objects. ",
            0,
            allObjects.size()
        );
        // for (Iterator all = allObjects.iterator(); all.hasNext(); ) {
        //    RoleAbstractRoot roleAbstractRoot = (RoleAbstractRoot) all.next();
        //    System.out.println("content: " + roleAbstractRoot.refGetPath() + " " + roleAbstractRoot.getIdentity());
        //}
        
  }
  
  /**
   * Setup numberOfObjects objects with a role. 
   * 
   * @param numberOfObjects
   * @throws Exception
   */
  private List setUpFindIteratingSorted(
      int numberOfObjects,
      List roleNames,
      String idPrefix
  ) throws Exception {
      // fill db with some values
      List objects = new ArrayList();
      String timer; 
      try {
      
      Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
      Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();

      // get segment singleton
      SegmentClass modelSegmentClass = pkg.getSegment();
      Segment modelSegment = modelSegmentClass.getSegment(rootSegment);

      RoleClassRoleARoleTypeClass roleARoleTypeClass = 
          pkg.getRoleClassRoleARoleType();

      for (Iterator r = roleNames.iterator(); r.hasNext();) {
          String roleName = (String) r.next();
          System.out.println(" create RoleType "+roleName+" ...");
          try {
              
              RoleClassRoleARoleType roleType = 
                  roleARoleTypeClass.createRoleClassRoleARoleType();
                  
              unitOfWork.begin();
              modelSegment.addAbstractRootRoleType(
                  roleName,
                  roleType
              );
              unitOfWork.commit();
          }
//        catch (JmiServiceException je) {
          catch (Exception je) {
              if (!isDuplicateException(je)) {
                  throw je;
              }
              else {
                  // do not need the role types
              }
          }
      } 
      
      System.out.println(" create the RoleClass objects ...");
      RoleClassClass roleClassClass = pkg.getRoleClass();
      RoleClassRoleAClass roleAClass = pkg.getRoleClassRoleA();
          
      for (int i = 0; i < numberOfObjects; i++) {
          StopWatch_1.instance().startTimer(timer = "createObjs");
          RoleClass roleClass = 
              roleClassClass.createRoleClass(
                  String.valueOf(i),
                  String.valueOf(numberOfObjects - i )
              );
          roleClass.setAaaa(
              new String[] {String.valueOf(i), String.valueOf((int) (i % 10))});
          roleClass.setBbbb(
              new String[] {String.valueOf(i), String.valueOf((int) (i % 100))});
          
          unitOfWork.begin();
          modelSegment.addRoleAbstractRoot(
              idPrefix + String.valueOf(i),
              roleClass
          );
          unitOfWork.commit();
          StopWatch_1.instance().stopTimer(timer);
          objects.add(roleClass);
      }
      
      for (Iterator r = roleNames.iterator(); r.hasNext();) {
          String roleName = (String)r.next();
          System.out.println("add role " + roleName);
          
          for (int i = 0; i < numberOfObjects; i++) {
              StopWatch_1.instance().startTimer(timer = "create_" + roleName);
              
              RoleClass roleClass = (RoleClass) objects.get(i);
              // add role
              RoleClassRoleA roleA = null;
    
              unitOfWork.begin();
              roleA = roleAClass.extendRoleClass(
                  roleClass, "rcra" + String.valueOf(i));
              roleA.setDddd(new String[] {
                      "role " + String.valueOf((int) (i % 10)) , 
                      roleName,
                      "dddd" 
                  }
              );
              // must be unique (defined through RoleType reference)
              roleA.setIdent("ident" + String.valueOf(i));
              roleClass.addRole(roleName, roleA);
              unitOfWork.commit();      
              StopWatch_1.instance().stopTimer(timer);    
          }
      }
      
      System.out.println();
      System.out.println(" created " + numberOfObjects + " entries ");
      
      return objects;

      }
      catch (Exception se) {
          showException(se);
          throw se;
      }
  }
  
  private void checkOrder(
      Collection result, 
      String attribute, 
      short order
  )  {
    String lastValue = null;
    int count = 0;
    
    for (Iterator i = result.iterator();
      i.hasNext();
    ) {
      count++;
      RoleClass res = (RoleClass) i.next();
      String actualValue = null; 
      if (attribute.equals("aaaa")) {
          actualValue = (String)res.getAaaa().get(0);
      }
      else if (attribute.equals("bbbb")) {
          actualValue = (String)res.getBbbb().get(0);
      }
      else if (attribute.equals("dddd")) {
          RoleClassRoleA resRole = (RoleClassRoleA) res;
          actualValue = (String)resRole.getDddd().get(0);
      }
      else if (attribute.equals("rcraName")) {
          RoleClassRoleA resA = (RoleClassRoleA) res;
          actualValue = resA.getRcraName();
      }

      System.out.print(" " + actualValue);
      if ((count%80) == 0) { System.out.println(); }
      
      if (order == Orders.ASCENDING && lastValue != null) {
          assertTrue(
            "ASCENDING order for " + attribute + " is wrong: \"" + lastValue + "\" preceeds \"" + actualValue + '"',
            lastValue.compareTo(actualValue) <= 0
          ); 
      }
      else if (order == Orders.DESCENDING && lastValue != null ) {
          assertTrue (
            "DESCENDING order for " + attribute + " is wrong: \"" + lastValue + "\" preceeds \"" + actualValue + '"',
            lastValue.compareTo(actualValue) >= 0
          ); 
      }
      lastValue = actualValue;
    }
    System.out.println();
  }
  
    
  
  /**
   * Test iteration and sorting in an iteration.
   * 
   * @throws Exception
   */
  public void testFindIteratingSorted(
  ) throws Exception {
    try {
      RoleClassQuery filter = null;
      RoleClassRoleAQuery rcafilter = null;
      Date start = null;
      Date end = null;
      Container results = null;
      List resultList = null;

      int numberOfObjects = 20;  // specify n times batchSize, otherwise the test is useless
      
      String roleName = "extraRole";
      
      // initialise Data: 
      List roleNames = new ArrayList();
      roleNames.add(roleName);
      removeRoleClassesFromSegment();
      setUpFindIteratingSorted(numberOfObjects, roleNames, "iterSort ");
      
      Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
      
      // get segment singleton
      SegmentClass modelSegmentClass = pkg.getSegment();
      Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
      
      
      {
          // get all sorted (testing iteration continuation)
          filter = pkg.createRoleClassQuery();
          filter.orderByName().descending();
  
          System.out.println(" start finding all objects .... ");
          
          start = new Date();
          
          // List results = modelSegment.getRoleAbstractRoot(filter); 
          results = (Container) modelSegment.getRoleAbstractRoot();
          resultList = results.toList(filter);
          
          end = new Date();
          // make sure to get all 
          
          System.out.println(
              " got some after " + 
              String.valueOf(end.getTime() - start.getTime())
          );
          
          start = new Date();
          for (Iterator i = resultList.iterator(); i.hasNext(); ) {
              // RoleAbstractRoot object = (RoleAbstractRoot)
                  i.next();
              // System.out.println("found " +  object+ " path: " + object.refGetPath() + " identity: " + object.getIdentity());
          }
          end = new Date();
          System.out.println(" got the rest after " + 
              String.valueOf(end.getTime() - start.getTime())
          );
          System.out.println(" got " + resultList.size());
          
          
            assertEquals(
                "resultList.size()", 
                numberOfObjects, 
                resultList.size()
            );
  
          checkOrder(resultList, "name", Orders.DESCENDING);
      }
      
      {
          // get a small subSet sorted
          filter = pkg.createRoleClassQuery();
          filter.thereExistsBbbb().equalTo("99");
          filter.orderByAaaa().descending(0);
  
          System.out.println(" start finding objects with bbbb = 99 .... ");
          
          start = new Date();
          
          // List results = modelSegment.getRoleAbstractRoot(filter); 
          results = (Container) modelSegment.getRoleAbstractRoot();
          resultList = results.toList(filter);
          
          end = new Date();
          // make sure to get all 
          
          System.out.println(
              " got some after " + 
              String.valueOf(end.getTime() - start.getTime())
          );
          
          int count = 0;
          start = new Date();
          for (Iterator i = resultList.iterator(); i.hasNext(); ) {
              i.next();
              count++;
          }
          end = new Date();
          System.out.println(" got the rest after " + 
              String.valueOf(end.getTime() - start.getTime())
          );
          System.out.println(" got " + resultList.size());
          assertEquals(
              "resultList.size()", 
              (int)numberOfObjects/100, 
              resultList.size()
          );
          
          assertEquals(
              "resultList.size() == count", 
              count, 
              resultList.size()
          );

          checkOrder(resultList, "aaaa", Orders.DESCENDING);
      }
      
      {
          // get a bigger subset sorted
          filter = pkg.createRoleClassQuery();
          filter.thereExistsAaaa().equalTo("9");
          filter.orderByAaaa().descending(0);
  
          System.out.println(" start finding objects with aaaa = 9 .... ");
          start = new Date();
          
  //        results = modelSegment.getRoleAbstractRoot(filter);
          results = (Container) modelSegment.getRoleAbstractRoot();
          resultList = results.toList(filter);
   
          end = new Date();
          
          // make sure to get all 
          System.out.println(
              " got some after " + 
              String.valueOf(end.getTime() - start.getTime())
  
          );
          start = new Date();
          int count = 0;
          for (Iterator i = resultList.iterator(); i.hasNext(); ) {
              count++;
              i.next();
          }
          end = new Date();
          System.out.println("");
          System.out.println(" got the rest after " + 
              String.valueOf(end.getTime() - start.getTime())
          );
  
          System.out.println(" got " + resultList.size());
            assertEquals(
                "resultList.size()", 
                (int)numberOfObjects/10, 
                resultList.size()
            );
          
          assertEquals(
              "resultList.size() == count", 
              count, 
              resultList.size()
          );
          
          checkOrder(resultList, "aaaa", Orders.DESCENDING);
      }
      {
          // find iterating with sort on role attribute dddd
          System.out.println(" start finding all sorted by role attribute dddd .... "); 
          rcafilter = pkg.createRoleClassRoleAQuery();
          rcafilter.thereExistsObject_inRole().equalTo(roleName);
          rcafilter.orderByDddd().descending(0);
                 
          start = new Date();
          results = (Container) modelSegment.getRoleAbstractRoot();
          resultList = results.toList(rcafilter);
   
          end = new Date();
          
          // make sure to get all 
          System.out.println(
              " got some after " + 
              String.valueOf(end.getTime() - start.getTime())
  
          );
          start = new Date();
          int count = 0;
          for (Iterator i = resultList.iterator(); i.hasNext(); ) {
              count++;
              i.next();
              // need some feedback
          }
          end = new Date();
          System.out.println("");
          System.out.println(" got the rest after " + 
              String.valueOf(end.getTime() - start.getTime())
          );
  
          System.out.println(" got " + resultList.size());
          assertEquals(
              "resultList.size()", 
              numberOfObjects, 
              resultList.size()
          );
          
          assertEquals(
              "resultList.size() == count", 
              count, 
              resultList.size()
          );
          
          checkOrder(resultList, "dddd", Orders.DESCENDING);
      }
      {
          // find with filter on core attribute and sort on role attribute
          System.out.println(" start finding roles with bbbb = 7 order by role attribute rcraName...");
          rcafilter = pkg.createRoleClassRoleAQuery();
          rcafilter.thereExistsBbbb().equalTo("7");
          rcafilter.thereExistsObject_inRole().equalTo(roleName);
          rcafilter.orderByRcraName().descending();
                 
          start = new Date();
          // results = modelSegment.getRoleAbstractRoot(rcafilter); 
          results = (Container) modelSegment.getRoleAbstractRoot();
          resultList = results.toList(rcafilter);
          
          end = new Date();
          
          // make sure to get all 
          System.out.println(
              " got some after " + 
              String.valueOf(end.getTime() - start.getTime())
  
          );
          start = new Date();
          int count = 0;
          for (Iterator i = resultList.iterator(); i.hasNext(); ) {
              count++;
              //RoleAbstractRoot rar = (RoleAbstractRoot)
                  i.next();
              //System.out.println(count + ": " + rar);
          }
          end = new Date();
          System.out.println("");
          System.out.println(" got the rest after " + 
              String.valueOf(end.getTime() - start.getTime())
          );
  
          System.out.println(" got " + resultList.size());
          assertEquals(
              "resultList.size()", 
              1 + ((int)numberOfObjects - 7 )/100, 
              resultList.size()
          );
          
          assertEquals(
              "count == resultList.size()", 
              count, 
              resultList.size()
          );
          
          checkOrder(resultList, "rcraName", Orders.DESCENDING);
      }
      {
          // find with filter on role attribute and sort on role attribute
          System.out.println(" start finding roles with role attribute dddd = 'role 7' order by role attribute rcraName...");
          rcafilter = pkg.createRoleClassRoleAQuery();
          rcafilter.thereExistsDddd().equalTo("role 7");
          rcafilter.thereExistsObject_inRole().equalTo(roleName);
          rcafilter.orderByRcraName().descending();
                 
          start = new Date();
          // results = modelSegment.getRoleAbstractRoot(rcafilter); 
          results = (Container) modelSegment.getRoleAbstractRoot();
          resultList = results.toList(rcafilter);
          
          end = new Date();
          
          // make sure to get all 
          System.out.println(
              " got some after " + 
              String.valueOf(end.getTime() - start.getTime())
  
          );
          start = new Date();
          int count = 0;
          for (Iterator i = resultList.iterator(); i.hasNext(); ) {
              count++;
              i.next();
          }
          end = new Date();
          System.out.println("");
          System.out.println(" got the rest after " + 
              String.valueOf(end.getTime() - start.getTime())
          );
  
          System.out.println(" got " + resultList.size());
          assertEquals(
              "resultList.size()", 
              (int)numberOfObjects/10, 
              resultList.size()
          );
          
          assertEquals(
              "resultList.size() == count", 
              count, 
              resultList.size()
          );
          
          checkOrder(resultList, "rcraName", Orders.DESCENDING);
      }
      }
      catch (Exception se) {
          showException(se);
          throw se;
      }
  }     
        
  private void checkCountAndType(
    int count,
    Class type, 
    Collection results
  ) {
    for(
      Iterator i = results.iterator();
      i.hasNext();
    ) {
      Role object = (Role)i.next();
      assertTrue(
        "object " + i + " not of correct type. expected " + type + " received " + object.getClass(),
        type.isAssignableFrom(object.getClass())
      );
      // RoleType roleType = ((Role)object).getRoleType();
    }
    
    // now that we have all read, check count        
    assertTrue(
      " expected " + count + 
      " objects to be found, there were " + results.size(),
      results.size() == count
    );
  }
  
  private void cleanDBForRoleTypeAccessById(
    Role1Package pkg,
    Segment modelSegment,
    String roleNoRoleName
  ) {
      Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
    try {
      // need to delete objects to get clean db. Do it before start
      // to get the chance to have a look at the db
      System.out.println(" deleting the objects from db...");
      unitOfWork.begin();
      // this deletes all depending objects
      modelSegment.removeRoleNoRole(roleNoRoleName);
      unitOfWork.commit();
      // what about roleTypes, need to delete from roleNoRole...
      // 
      //    roleNoRole.removeRoleClassDRoleType(...);
      }
      catch (Exception e) {
        if (unitOfWork.isActive()) {
            unitOfWork.rollback();
        }

      }
    }
        
        
private void printEmployee(Employee employee) {
    java.text.SimpleDateFormat outsdf = 
        new java.text.SimpleDateFormat("dd.MM.yyyy");
  System.out.println("name          = " + employee.getName());
  System.out.println("birthdate     = " + 
      outsdf.format(employee.getBirthdate()));
  System.out.println("division      = " + employee.getDivision());
  System.out.println("businessPhone = " + employee.getBusinessPhone());
  System.out.println("inRole        = " + employee.getObject_inRole());
  System.out.println("hasRole       = " + employee.getObject_hasRole());
}

    /** 
     * Code used in documentation. 
     * Fragments used in documentation start at column 0. If they are changed
     * the documentation should be adapted as well!
     */
    public void testDocu(
    ) throws Exception {
        try {
            Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
            Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
    
            SegmentClass modelSegmentClass = pkg.getSegment();
            unitOfWork.begin();
            Segment segment = modelSegmentClass.getSegment(rootSegment);
            unitOfWork.commit();

            try {
                unitOfWork.begin();
                segment.removePerson("john1");
                unitOfWork.commit();
            }
            catch (JmiException je) {
                if (!isNotFoundException(je)) {
                    throw je;
                }
                if (unitOfWork.isActive()) {
                    unitOfWork.commit();
                }
            }
             
            unitOfWork.begin();
EmployeeRoleTypeClass employeeRoleTypeClass = pkg.getEmployeeRoleType();
PersonClass personClass = pkg.getPerson();
EmployeeClass employeeClass = pkg.getEmployee();
            CustomerClass customerClass = pkg.getCustomer();
unitOfWork.commit();

             
System.out.println("create RoleTypes \"Clerk\" and \"Manager\" ");
          try { // roleTypes can't be removed!
unitOfWork.begin();

segment.addPersonRoleType(
    "Clerk", 
    employeeRoleTypeClass.createEmployeeRoleType()
);
unitOfWork.commit();

            } 
            catch (Exception ex) {
                if (unitOfWork.isActive()) {
                    unitOfWork.commit();
                }
            }
            
            try {
unitOfWork.begin();
segment.addPersonRoleType(
    "Manager", 
    employeeRoleTypeClass.createEmployeeRoleType()
);
unitOfWork.commit();

            } 
            catch (Exception ex) {
                if (unitOfWork.isActive()) {
                    unitOfWork.commit();
                }
            }
            try {
                unitOfWork.begin();

                segment.addPersonRoleType(
                    "Customer",
                    pkg.getCustomerRoleType().createCustomerRoleType()
                );
                unitOfWork.commit();

            } 
            catch (Exception ex) {
                if (unitOfWork.isActive()) {
                    unitOfWork.commit();
                }
            }
            
             
System.out.println("create core ");
Calendar calendar = new GregorianCalendar();
calendar.set(1975, Calendar.AUGUST, 6);

unitOfWork.begin();
  Person john = personClass.createPerson(
    calendar.getTime(),
    "John"
);
//segment.addPerson("john1", john);
System.out.println("add  role \"Clerk\" to person john ");
Employee employee = employeeClass.extendPerson(john, "1131", "Food");           
john.addRole("Clerk", employee);
segment.addPerson("john1", john);
unitOfWork.commit();

unitOfWork.begin();
  System.out.println("add  role \"Manager\" to person john ");
employee = employeeClass.extendPerson(john, "3331", "FoodMarketing");
john.addRole("Manager", employee);
unitOfWork.commit();

            john = null;
            
System.out.println("\nget john as \"Manager\":");
// unitOfWork.begin();
john = segment.getPerson("john1");
System.out.println("john.name=" + john.getName());
Employee johnManager = (Employee) john.getRole("Manager");
printEmployee(johnManager);

System.out.println("\nget john as \"Clerk\": ");
Employee johnClerk = (Employee) john.getRole("Clerk");
printEmployee(johnClerk);

System.out.println("\nget john as \"Clerk\" from john as \"Manager\": ");
Employee johnClerk2 = (Employee) johnManager.getRole("Clerk");
printEmployee(johnClerk2);

          System.out.println("john.identity    : " + johnClerk2.getIdentity()); 
          System.out.println("john.MofId       : " + johnClerk2.refMofId());
          if(johnClerk2 instanceof RefObject_1_0) System.out.println("john.objGetResourceIdentifier: " + 
              ((RefObject_1_0)johnClerk2).refDelegate().objGetResourceIdentifier()
          );
          
System.out.println("\nget john from john as \"Manager\": ");
Person johnToo = (Person) johnManager.getCore();

          System.out.println("john.equals(johnToo) "+ john.equals(johnToo));
          System.out.println("john == johnToo "+ (john == johnToo));
          
          System.out.println("johnToo.MofId    : " + johnToo.refMofId());

          System.out.println("johnToo.getName(): " + johnToo.getName());
           
System.out.println("\naccessing john by its roleType reference:");
EmployeeRoleType managerRole = (EmployeeRoleType) 
    segment.getPersonRoleType("Manager");
johnManager = managerRole.getEmployee("3331");
// unitOfWork.commit();

printEmployee(johnManager);
          
          
          // test sis:
          unitOfWork.begin();
          Customer customer = customerClass.extendPerson(john, 1500);           
          johnToo.addRole("Customer", customer);
          unitOfWork.commit();

          System.out.println("johnToo.MofId    : " + johnToo.refMofId());
          
          Employee johnClerk3 = (Employee)customer.getRole("Clerk");
          printEmployee(johnClerk3);
          System.out.println("johnClerk3.MofId    : " + johnClerk3.refMofId());
          
          Customer johnCustomer = (Customer)johnClerk3.getRole("Customer");
          System.out.println("johnCustomer.MofId    : " + johnCustomer.refMofId());
          System.out.println("total purchase: " + johnCustomer.getTotalPurchase());
            
          unitOfWork.begin();
          segment.removePerson("john1");
          unitOfWork.commit();  
          
      }
      catch (Exception se) {
          showException(se);            
          throw se;         
      } 
  }
 
 
  /**
   * Access a role through role type when the id of the object is used as 
   * qualifying attribute
   */
  public void testRoleTypeAccessById(
  ) throws Exception {
      try {
          
          String idPrefix = "idRTAI";
          String roleDTypeName = idPrefix + "rd1TN";
          String roleNoRoleName = idPrefix + "noRole1";
          String roleClassDName = idPrefix + "rd1";
          RoleClassDRoleARoleType roleDType = null;            

          // String pathString = "ch::omex::test::role1/provider/" + this.getName() + "/segment/Standard/roleNoRole/" + roleNoRoleName + "/roleClassDRoleType/"+ roleDTypeName +"/roleClassDRoleA" ;

          // initialize testRole1 package
          //System.out.println("activating model...");
          Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
  
          // get segment singleton
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();
          
          cleanDBForRoleTypeAccessById(pkg, modelSegment, roleNoRoleName);
          
          RoleNoRoleClass roleNoRoleClass = 
              pkg.getRoleNoRole();
          RoleClassDClass classDClass =
              pkg.getRoleClassD();
          RoleClassDRoleAClass classDRoleAClass =
              pkg.getRoleClassDRoleA();
              
          RoleClassDRoleARoleTypeClass roleClassDRoleARoleTypeClass = 
              pkg.getRoleClassDRoleARoleType();


          System.out.println(" create RoleNoRole ...");
          unitOfWork.begin();
          RoleNoRole roleNoRole = 
              roleNoRoleClass.createRoleNoRole(
                  "roleDTest"
              );
          roleNoRole.setAaaa(
                  new String[] {"roleDtest", "aaaa string value"});
                         
          modelSegment.addRoleNoRole(
              roleNoRoleName,
              roleNoRole
          );
          unitOfWork.commit();
          
          System.out.println(" create RoleType needed ...");
          try {
              System.out.println("    " + roleDTypeName +"...");
              unitOfWork.begin();
              roleDType = 
                  roleClassDRoleARoleTypeClass.createRoleClassDRoleARoleType();
              roleNoRole.addRoleClassDRoleType(
                  roleDTypeName,
                  roleDType
              );
              unitOfWork.commit();
              // System.out.println(" ... done ");                
          }
//        catch (JmiServiceException je) {
          catch (Exception je) {
              if (!isDuplicateException(je)) {
                  throw je;
              }
              else {
                  // need the role type
//                    RoleClassRoleNoRoleClass roleNoRoleClass = null;
//                    roleDType = roleNoRoleClass.   modelSegment.getrgetAbstractRootRoleType
//                    for (int i=0; i < roleTypeCount; i++) {
//                        roleATypes[i] = (RoleClassRoleARoleType)
//                            modelSegment.getAbstractRootRoleType(roleATypeNames[i]);
//                    }
//                    roleAroleAroleType = (RoleClassRoleARoleARoleType)
//                    modelSegment.getAbstractRootRoleType(roleAroleATypeName);
              }
          }


          System.out.println(" create RoleClassD and RoleClassDRoleA objects ...");
          unitOfWork.begin();
          RoleClassD roleClassD = classDClass.createRoleClassD();
          roleClassD.setKkkk(new String[] {"kkkk", "kvalue"});
          roleClassD.setRcdName("rcdName");
                          
          roleNoRole.addRoleClassD(
              roleClassDName,
              roleClassD
          );
          unitOfWork.commit();
          
          unitOfWork.begin();
          RoleClassD roleD = 
              classDRoleAClass.extendRoleClassD(roleClassD, "rcrdaName");
          ((RoleClassDRoleA)roleD).setMmmm(new String[] { "mmmm" });
          
          roleClassD.addRole(roleDTypeName, roleD);
          unitOfWork.commit();
          
          // ####
          // we have all the objects prepared
          System.out.println(" access through roletype id ...");
          unitOfWork.begin();
          RoleClassDRoleAQuery roleDQuery = 
              pkg.createRoleClassDRoleAQuery();
          unitOfWork.commit();
                      
//            List results = roleDType.getRoleClassDRoleA(roleDQuery);
          unitOfWork.begin();
          Container results = (Container)roleDType.getRoleClassDRoleA();
          results = results.subSet(roleDQuery);

          checkCountAndType(1, RoleClassDRoleA.class, results);
          unitOfWork.commit();
          
          // ####
          System.out.println(" find through RoleType (find none)...");
          unitOfWork.begin();
          roleDQuery.thereExistsMmmm().equalTo("noMatch");
          
//            results = roleDType.getRoleClassDRoleA(roleDQuery);
          results = (Container)roleDType.getRoleClassDRoleA();
          results = results.subSet(roleDQuery);

          checkCountAndType(0, RoleClassDRoleA.class, results);
          unitOfWork.commit();
          
          /**
           * CR0001012: Adapt JUnit-Tests relying on path rewriting 
           *
          System.out.println(" access directly through id ...");
          // Hack: set path directly to roleClassRoleARoleA object
          Path roleTypePath = new Path(pathString).add(roleClassDName);
          unitOfWork.begin();            
          RoleClassDRoleA classDRoleAinst = 
              classDRoleAClass.getRoleClassDRoleA(
                roleTypePath.clone()
              );
          // get the object directly through this path
          classDRoleAinst.refDelegate().objRefresh(); 
          unitOfWork.commit();            
          assertTrue("path should change through refresh. before:" + 
              roleTypePath,
              !roleTypePath.equals(classDRoleAinst.refDelegate().objGetPath())
          );
          */
          RoleClassDRoleA classDRoleAinst = (RoleClassDRoleA)roleClassD.getRole(roleDTypeName);
          
          // spice2 had problems with objects contained in roles if the
          // references names by which the classes were contained were not 
          // distinct. 
          // Test for ambiguous reference leading from roled object 
          // in this case its roleClassFree, which leads from the two roles
          // RoleClassRoleARoleA and from RoleClassDRoleA. The test from the 
          // RoleClassRoleARoleA are contained in testRoleTypeAccess.
          System.out.println(" test ambiguous role reference");
          String roleClassFreeId = "ambiguousTest";
          String roleClassFreeName = "ambiguous Role reference";
          unitOfWork.begin();
          classDRoleAinst.addRoleClassFree(
              roleClassFreeId, 
              pkg.getRoleReferenceTest().createRoleReferenceTest(roleClassFreeName)
          );
          unitOfWork.commit();

          System.out.println(" get the ambiguous role reference");            
          RoleReferenceTest test = classDRoleAinst.getRoleClassFree(roleClassFreeId);
          assertTrue("expected to find a RoleReferenceTest object", test != null);
          assertEquals("wrong name", roleClassFreeName, test.getName());
              
          if(AbstractTestRoleJmi_1.cleanDb) {
              cleanDBForRoleTypeAccessById(pkg, modelSegment, roleNoRoleName);
          }

      }
      catch (Exception se) {
          showException(se);
          throw se;            
      } 
  }
  
  /**
   * Test the different accessing possibilities using RoleTypes. These are:
   * <ul>
   * <li> find role instance through RoleType </li>
   * <li> get role instance through RoleType </li>
   * <li> assert unique role instances on the attributes declared as unique 
   * within a RoleType </li>
   * </ul>
   */ 
  public void testRoleTypeAccess(
  ) throws Exception {
      try {
          int roleClassCount = 5;
          int roleTypeCount = 2;
          int roleClassFreeCount = 3;
          
          String idPrefix = "idRTA";
          String[] roleATypeNames = new String[2];
          RoleClassRoleARoleType[] roleATypes = new RoleClassRoleARoleType[2];
          String pathString = "xri:@openmdx:org.openmdx.test.compatibility.role1/provider/" + this.getName() + "/segment/Standard/abstractRootRoleType/idRTArara1/roleClassRoleARoleA";

          roleATypeNames[0] = idPrefix + "ra1";
          roleATypeNames[1] = idPrefix + "ra2";

          String roleAroleATypeName = idPrefix + "rara1";
          RoleClassRoleARoleARoleType roleAroleAroleType = null;
          
          // list of values in rcraName elements in RoleClassRoleARoleA
          ArrayList rcraNames = new ArrayList();
          

          // initialize testRole1 package
          //System.out.println("activating model...");
          Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
              
          // get segment singleton
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();

          
          // need to delete objects to get clean db. Do it before start
          // to get the chance to have a look at the db
          System.out.println(" deleting the objects from db...");
          // just delete topmost and get rid of 
          for (int i = 0; i < roleClassCount; i++) try {
            unitOfWork.begin();
              modelSegment.removeRoleAbstractRoot(
                  idPrefix + String.valueOf(i)
              );
            unitOfWork.commit();
//        } catch (JmiServiceException exception) {
          } catch (Exception exception) {
            assertTrue(
                "NOT_FOUND excpetion expected instead of " + exception,
                isNotFoundException(exception)
            );
            try {
                unitOfWork.rollback();
            } catch(Exception e) {}
          }

//      TODO: Verify whether it is correct to comment out the following statements due to the NOT_SUPPORTED 
//            exception "Removal of RoleType is not supported. It may still be in use in role objects." 
//          for (int i = 0;  i < roleTypeCount; i++) try {
//          unitOfWork.begin();
//              modelSegment.removeAbstractRootRoleType(roleATypeNames[i]);
//          unitOfWork.commit();
//        } catch (JmiServiceException exception) {
//          assertTrue(
//              "NOT_FOUND excpetion expected instead of " + exception,
//              isNotFoundException(exception)
//          );
//        }
//        try {
//          unitOfWork.begin();
//              modelSegment.removeAbstractRootRoleType(roleAroleATypeName);
//          unitOfWork.commit();
//        } catch (JmiServiceException exception) {
//          assertTrue(
//              "NOT_FOUND excpetion expected instead of " + exception,
//              isNotFoundException(exception)
//          );
//        }
   
          RoleClassClass roleClassClass = 
              pkg.getRoleClass();
          RoleClassRoleARoleTypeClass roleARoleTypeClass = 
              pkg.getRoleClassRoleARoleType();
          RoleClassRoleARoleARoleTypeClass roleAroleARoleTypeClass = 
              pkg.getRoleClassRoleARoleARoleType();
          
          RoleClassRoleAClass roleAClass = 
              pkg.getRoleClassRoleA();
          RoleClassRoleARoleAClass roleAroleAClass = 
              pkg.getRoleClassRoleARoleA();
          
          RoleClassFreeClass roleClassFreeClass =
              pkg.getRoleClassFree();
          
          System.out.println(" create RoleTypes needed ...");
          try {
              for (int i = 0; i < roleTypeCount; i++) {
                  System.out.println("    " + roleATypeNames[i] +"...");
              
                  RoleClassRoleARoleType roleType = 
                      roleARoleTypeClass.createRoleClassRoleARoleType();
                  roleATypes[i] = roleType;
                  unitOfWork.begin();
                  modelSegment.addAbstractRootRoleType(
                      roleATypeNames[i],
                      roleType
                  );
                  unitOfWork.commit();
                  // System.out.println(" ... done ");
              }
              
              roleAroleAroleType = roleAroleARoleTypeClass.createRoleClassRoleARoleARoleType();
              roleAroleAroleType.setCoreRole(roleATypeNames[0]);
              unitOfWork.begin();
              modelSegment.addAbstractRootRoleType(
                  roleAroleATypeName,
                  roleAroleAroleType
              );
              unitOfWork.commit();
          }
//        catch (JmiServiceException je) {
          catch (Exception je) {
              if (unitOfWork.isActive()) {
                  unitOfWork.rollback();
              }

              if (!isDuplicateException(je)) {
                  throw je;
              }
              else {
                  // need the role types
                  unitOfWork.begin();
                  for (int i=0; i < roleTypeCount; i++) {
                      roleATypes[i] = (RoleClassRoleARoleType)
                          modelSegment.getAbstractRootRoleType(roleATypeNames[i]);
                  }
                  roleAroleAroleType = (RoleClassRoleARoleARoleType)
                  modelSegment.getAbstractRootRoleType(roleAroleATypeName);
                  unitOfWork.commit();
              }
          }

          System.out.println(" create some RoleClass and RoleClassRoleA objects ...");
          String indentation = ""; 
          
          for (int i = 0; i < roleClassCount; i++) {
              unitOfWork.begin();
              RoleClass roleClass = 
                  roleClassClass.createRoleClass(
                      "nameValue",
                      "rcNameValue"
                  );
                  roleClass.setBbbb(
                      new String[] {String.valueOf(i), "b string values"});
                  roleClass.setAaaa(
                      new String[] {String.valueOf(i), String.valueOf(i%2), "a string values"});
                             
              modelSegment.addRoleAbstractRoot(
                  idPrefix + String.valueOf(i),
                  roleClass
              );
              unitOfWork.commit();
              System.out.println(" roleClass: <" + idPrefix + String.valueOf(i) + "> ");
              indentation = "    ";
              String roleAindent = new String(indentation); 
              
              for (int j = 0; j<roleATypeNames.length; j++) {
                  String rcraName = "rcra object[" + i + "] role:: " + roleATypeNames[j];
                  unitOfWork.begin();
                  rcraNames.add(rcraName);
//                    RoleClassRoleA roleA = 
//                        roleAClass.extendRoleClass(
//                            roleClass,  
//                            new String[] {
//                                String.valueOf(i) + "." + String.valueOf(j), 
//                                roleATypeNames[j],
//                                "dddd"
//                            },
//                            // this must be unique (defined through RoleType reference)
//                            rcraName
//                        );

                  RoleClassRoleA roleA = roleAClass.extendRoleClass(
                      roleClass, rcraName);
                  
                  roleA.setDddd(new String[] {
                          String.valueOf(i) + "." + String.valueOf(j), 
                          roleATypeNames[j],
                          "dddd"
                      }
                  );
                  roleA.setIdent("t23434" + Integer.toString(i)+ "_" +Integer.toString(j)); // qualifying attribute must get a value
                  //roleA.refUnedit();
                      
                  roleClass.addRole(roleATypeNames[j], roleA);  
                  unitOfWork.commit(); 
                  System.out.println(roleAindent + "roleA.rcraName: <" + rcraName  + ">"); 
                  String roleAroleAindent = roleAindent + "    "; 
                  
                  if (j == 0) {
//                        System.out.println(" create a RoleARoleA Object to " + 
//                            idPrefix + String.valueOf(i) + " and " +
//                            roleATypeNames[j] +  ".... ");
                      String rc2raName = "name rc2ra " + String.valueOf(i);
                      unitOfWork.begin();
                      RoleClassRoleARoleA roleAroleA = 
                          roleAroleAClass.extendRoleClassRoleA(roleA, rc2raName);
                      roleAroleA.setGggg(new String[] {
                              String.valueOf(i % 2),
                              "gggg"
                          }
                      );
                      //roleAroleA.refUnedit();
                             
                      roleA.addRole(
                          roleAroleATypeName,
                          roleAroleA
                      );
                      unitOfWork.commit();
                      System.out.println(roleAroleAindent + "roleArolaA.rcraraName: <" + rc2raName  + ">"); 
                      String rcfIndent = roleAroleAindent + "    " ;

                      // add some roleClassFree objects
                      for (int f = 0; f < roleClassFreeCount; f++) {
                          unitOfWork.begin();
                          RoleClassFree free = 
                              roleClassFreeClass.createRoleClassFree();
                          free.setAaaa(
                              new String[] { 
                                  String.valueOf(f), 
                                  String.valueOf(f%2), 
                                  "aaaa"
                              }
                          );
                          
                          free.setName("name");
                          
                          roleAroleA.addRoleClassFree(
                              idPrefix + String.valueOf(f), 
                              free
                          );
                          if(roleAroleA instanceof RefObject_1_0)
                          // DataproviderObject_1_0 dpo = 
                              ((RefObject_1_0)roleAroleA).refDelegate();
                              
                          unitOfWork.commit();
                          System.out.println(rcfIndent + " RoleClassFree id: " + idPrefix + String.valueOf(f));
                      }
                  }
              }
          }
                      
          // 
          // first some finds
          //
          
          // ####
          System.out.println(" find through RoleType (find all) ...");
          RoleClassRoleAQuery roleAQuery = 
              pkg.createRoleClassRoleAQuery();
          
//            roleAQuery.thereExistsDddd().equalTo(roleATypeNames[0]);
          
          // List results = roleATypes[0].getRoleClassRoleA(roleAQuery);
          unitOfWork.begin();
          Container results = (Container)roleATypes[0].getRoleClassRoleA();
          results = results.subSet(roleAQuery);
          
          checkCountAndType(roleClassCount, RoleClassRoleA.class, results);
          unitOfWork.commit();
          
          // ####
          System.out.println(" find through RoleType (find none)...");
          roleAQuery.thereExistsDddd().equalTo(roleATypeNames[1]);  // not matching to roleType
          
//            results = roleATypes[0].getRoleClassRoleA(roleAQuery);
          unitOfWork.begin();

          results = (Container)roleATypes[0].getRoleClassRoleA();
          results = results.subSet(roleAQuery);
          checkCountAndType(0, RoleClassRoleA.class, results);
          unitOfWork.commit();

         
           // ####
          System.out.println(" find through RoleType (find some) ...");
          roleAQuery = 
              pkg.createRoleClassRoleAQuery();
          
          roleAQuery.thereExistsAaaa().equalTo("0");
          
//            results = roleATypes[0].getRoleClassRoleA(roleAQuery);
          unitOfWork.begin();
          results = (Container)roleATypes[0].getRoleClassRoleA();
          results = results.subSet(roleAQuery);

          
          checkCountAndType((1+(roleClassCount/2)), RoleClassRoleA.class, results);
          unitOfWork.commit();
          
          // ####
          System.out.println(" find roleAroleA through RoleType (find some) ...");
          RoleClassRoleARoleAQuery roleAroleAQuery = 
              pkg.createRoleClassRoleARoleAQuery();
          
          roleAroleAQuery.thereExistsGggg().equalTo("0");
          
//            results = roleAroleAroleType.getRoleClassRoleARoleA(roleAroleAQuery);
          unitOfWork.begin();
          results = (Container)roleAroleAroleType.getRoleClassRoleARoleA();
          results = results.subSet(roleAroleAQuery);

          checkCountAndType((1+(roleClassCount/2)), RoleClassRoleARoleA.class, results);
          unitOfWork.commit();

          // ####
          System.out.println(" find RoleClassFree through RoleType (find all) ...");
          RoleClassFreeQuery freeQuery = pkg.createRoleClassFreeQuery();
          freeQuery.thereExistsAaaa().equalTo("aaaa");
          // Hack: set path directly to roleClassRoleARoleA object
          unitOfWork.begin();

          RoleClassRoleARoleA roleAroleA = 
              roleAroleAClass.getRoleClassRoleARoleA(
                new Path(pathString).add((String)rcraNames.get(0))
              );
          // roleAClass.refresh() would get the object, which would change 
          // the path! 
          
//            results = roleAroleA.getRoleClassFree(freeQuery);
          results = (Container)roleAroleA.getRoleClassFree();
          results = results.subSet(freeQuery);

          checkCountAndType(roleClassFreeCount, RoleClassFree.class, results);
          unitOfWork.commit();

          // ####
          System.out.println(" find RoleClassFree through RoleType (find some) ...");
          freeQuery = pkg.createRoleClassFreeQuery();
          freeQuery.thereExistsAaaa().equalTo("0");
          // Hack: set path directly to roleClassRoleARoleA object
          unitOfWork.begin();

          roleAroleA = 
              roleAroleAClass.getRoleClassRoleARoleA(
                new Path(pathString).add((String)rcraNames.get(0))
              );
          // roleAClass.refresh() would get the object, which would change 
          // the path! 
          
//            results = roleAroleA.getRoleClassFree(freeQuery);
          results = (Container)roleAroleA.getRoleClassFree();
          results = results.subSet(freeQuery);

          checkCountAndType((roleClassFreeCount/2)+1, RoleClassFree.class, results);
          unitOfWork.commit();

          // #### 
          System.out.println(" find RoleClassFree through RoleType (find none by filter) ...");
          freeQuery = pkg.createRoleClassFreeQuery();
          freeQuery.thereExistsAaaa().equalTo("0");
          freeQuery.name().equalTo("non existing value");

          // Hack: set path directly to roleClassRoleARoleA object 
          unitOfWork.begin();
        
          roleAroleA = 
              roleAroleAClass.getRoleClassRoleARoleA(
                new Path(pathString).add((String)rcraNames.get(0))
              );
          // roleAClass.refresh() would get the object, which would change 
          // the path! 
          
//            results = roleAroleA.getRoleClassFree(freeQuery);
          results = (Container)roleAroleA.getRoleClassFree();
          results = results.subSet(freeQuery);

          checkCountAndType(0, RoleClassFree.class, results);
          unitOfWork.commit();

          // #### 
          System.out.println(" find RoleClassFree through RoleType (find none by path) ...");
          freeQuery = pkg.createRoleClassFreeQuery();
          freeQuery.thereExistsAaaa().equalTo("aaaa");

          // Hack: set path directly to roleClassRoleARoleA object    
          // using rcraNames element which does not have a roleAroleA attached       
//            roleAroleA = 
//                roleAroleAClass.getRoleClassRoleARoleA(
//                  new Path(pathString).add((String)rcraNames.get(1))
//                );
          // roleAClass.refresh() would get the object, which would change 
          // the path! 
          try {
              // Hack: set path directly to roleClassRoleARoleA object    
              // using rcraNames element which does not have a roleAroleA attached     
              unitOfWork.begin();

              roleAroleA = roleAroleAClass.getRoleClassRoleARoleA(
                new Path(pathString).add((String)rcraNames.get(1))
              );
              
              // roleAClass.refresh() would get the object, which would change 
              // the path! 
              // --> no longer with 

//                results = roleAroleA.getRoleClassFree(freeQuery);
              results = (Container)roleAroleA.getRoleClassFree();
              results = results.subSet(freeQuery);

              checkCountAndType(0, RoleClassFree.class, results);
              unitOfWork.commit();
              
              assertTrue("expected exception", false);
          }
//        catch(JmiServiceException se) {
//          this.verifyException(
//            se.getExceptionStack(),
          catch(Exception se) {
            this.verifyException(
              se,
              BasicException.Code.NOT_FOUND,
              null
            );
            unitOfWork.rollback();
          }

          // 
          // now some gets
          //
          
          // #### 
          System.out.println(" get roleA through RoleType (get existing)...");   
//            results = new ArrayList();
//            results = (Container)roleAroleA.getRoleClassFree();
//            results = results.subSet(freeQuery);
//
//            results.add(
//                 roleATypes[0].getRoleClassRoleA((String) rcraNames.get(0))
//            );
          unitOfWork.begin();
          RoleClassRoleA roleClassRoleA = 
              roleATypes[0].getRoleClassRoleA((String) rcraNames.get(0));
          
          ArrayList getResults = new ArrayList();
          getResults.add(
              roleClassRoleA     //roleATypes[0].getRoleClassRoleA((String) rcraNames.get(0))
          );
          
          checkCountAndType(1, RoleClassRoleA.class, getResults);
          unitOfWork.commit();

           // #### 
          System.out.println(" get roleA through RoleType (get none by path)...");          
          
          // access through another roleType
          unitOfWork.begin();

          assertTrue(
              "expected not found exception",
              roleATypes[1].getRoleClassRoleA((String) rcraNames.get(0)) == null
          );
          unitOfWork.commit();

          // ####
          System.out.println(" get roleAroleA through RoleType (get existing)...");
          getResults.clear();
          
          unitOfWork.begin();

          getResults.add(
               roleAroleAroleType.getRoleClassRoleARoleA((String) rcraNames.get(0))
          );           
          checkCountAndType(1, RoleClassRoleARoleA.class, getResults);
          unitOfWork.commit();

           // #### 
          System.out.println(" get roleAroleA through RoleType (get none by path)...");          
          
          // accessing another rcraNames
          unitOfWork.begin();
          assertTrue(
              "expected not found exception",
              roleAroleAroleType.getRoleClassRoleARoleA((String) rcraNames.get(1)) == null
          );
          unitOfWork.commit();

          // ####
          System.out.println(" get RoleClassFree through RoleType (get existing) ...");
          // Hack: set path directly to roleClassRoleARoleA object
          unitOfWork.begin();

          roleAroleA = 
              roleAroleAClass.getRoleClassRoleARoleA(
                new Path(pathString).add((String)rcraNames.get(0))
              );
          unitOfWork.commit();

          // roleAClass.refresh() would get the object, which would change 
          // the path! 
//            results = new  ArrayList();
//            results.add(
//                roleAroleA.getRoleClassFree(idPrefix + String.valueOf(1))
//            );
          getResults.clear();
          unitOfWork.begin();

          getResults.add(
              roleAroleA.getRoleClassFree(idPrefix + String.valueOf(1)));

          checkCountAndType(1, RoleClassFree.class, getResults);
          unitOfWork.commit();

          // ####
          System.out.println(" get RoleClassFree through RoleType (get none by path) ...");
          // Hack: set path directly to roleClassRoleARoleA object
          
//            roleAroleA = 
//                roleAroleAClass.getRoleClassRoleARoleA(
//                  new Path(pathString).add((String)rcraNames.get(1))
//                );
          // roleAClass.refresh() would get the object, which would change 
          // the path! 
          try {
              unitOfWork.begin();

              roleAroleA = 
                  roleAroleAClass.getRoleClassRoleARoleA(
                    new Path(pathString).add((String)rcraNames.get(1))
                  );

              results.add(
                  roleAroleA.getRoleClassFree(idPrefix + String.valueOf(1))
              );
              unitOfWork.commit();
          }
//        catch(JmiServiceException se) {
//          this.verifyException(
//            se.getExceptionStack(),
          catch(Exception se) {
            this.verifyException(
              se,
              BasicException.Code.NOT_FOUND,
              null
            );
            unitOfWork.rollback();
          }
//        catch (RuntimeServiceException e) {
//            this.verifyException(
//                e.getExceptionStack(),
//                BasicException.Code.NOT_FOUND,
//                null
//            );
//            unitOfWork.rollback();
//        }


          // ####
          System.out.println(" get RoleClassFree through RoleType (get none by id) ...");
          // Hack: set path directly to roleClassRoleARoleA object
          
          unitOfWork.begin();
          roleAroleA = 
              roleAroleAClass.getRoleClassRoleARoleA(
                new Path(pathString).add((String)rcraNames.get(0))
              );
          // roleAClass.refresh() would get the object, which would change 
          // the path! 
          RoleClassFree free = roleAroleA.getRoleClassFree(idPrefix + String.valueOf(-1));
          if(free != null) {
            results.add(free);
          }
          unitOfWork.commit();
      }
      catch (Exception se) {
          showException(se);
          throw se;
      } 
  }


//  private void compareDataproviderObjects(
//      DataproviderObject_1_0 result,
//      DataproviderObject_1_0 expect
//  ) {
//      for (Iterator i = result.attributeNames().iterator();
//          i.hasNext();
//      ) {
//          String attributeName = (String) i.next(); 
//          if (
//              !attributeName.equals(SystemAttributes.OBJECT_MODIFIED_AT) && 
//              !attributeName.equals(SystemAttributes.OBJECT_CREATED_AT)
//          ) {
//              assertTrue("differing " + attributeName + 
//                  " Expected: " + expect.values(attributeName) +
//                  " Received: " + result.values(attributeName),
//                  expect.values(attributeName).equals(result.values(attributeName))
//              );
//          }
//      }
//      
//      // compare path 
//      assertTrue(" differing paths : " + 
//          "\n Expected: " + expect.path() +
//          "\n Received: " + result.path(),
//          result.path().equals(expect.path())
//      );
//  }


  private void tearDownMultipleQualifyingAttributes(
      Segment modelSegment,
      String[] roleAids
  ) throws Exception {
                  
      try {
          // need to delete objects to get clean db. 
          for (int i = 0; i < roleAids.length; i++) {
              modelSegment.removeRoleAbstractRoot(roleAids[i]);
          }
      }
      catch (Exception e) {
      }
  }
  
  public void testPerformance(
  ) throws Exception {
      
//      // first test StopWatch
//      long total = 0;
//      Date start = new Date();
//      for (int j =0; j < 1000; j++){
//      for (int i = 0; i < 10000; i++) {
//          StopWatch_1.instance().startTimer("Timer1");
//          total += 1;
//          StopWatch_1.instance().stopTimer("Timer1");
//      }
//      }
//      Date stop = new Date();
//      long time = (stop.getTime() -start.getTime());
//      System.out.println("test took: " + time+ " milliseconds for " + total + " runs. " );
          
      TreeStopWatch TSW = new TreeStopWatch();
      StopWatch_1.setStopWatch(TSW);
      
      TSW.switchTest("testPerformance");
      String testId = "cri";
      
      String role1 = "tfira1";
      String role2 = "tfira2";
      
      String timer;

      final int num = 10;
      
      List roleNames = new ArrayList();
      roleNames.add(role1);
      roleNames.add(role2);
      
      Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
      Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();

      SegmentClass modelSegmentClass = pkg.getSegment();
      Segment segment = modelSegmentClass.getSegment(rootSegment);

      RoleClass[] baseObjects = new RoleClass[num];
      RoleClassRoleA[] role1Objects = new RoleClassRoleA[num];
      RoleClassRoleA[] role2Objects = new RoleClassRoleA[num];

      removeRoleClassesFromSegment();
      setUpFindIteratingSorted(num, roleNames, testId);
      
      // get the base objects
      for (int i = 0; i < num; i++) {
          StopWatch_1.instance().startTimer(timer = "getObjs");
          unitOfWork.begin();
          baseObjects[i] = (RoleClass) segment.getRoleAbstractRoot(testId  + String.valueOf(i));
          unitOfWork.commit();
          StopWatch_1.instance().stopTimer(timer);
      }
      
      // get role1
      for (int i = 0; i < num; i++) {
          StopWatch_1.instance().startTimer(timer = "getRole_"+role1);
          unitOfWork.begin();
          role1Objects[i] = (RoleClassRoleA)baseObjects[i].getRole(role1);
          unitOfWork.commit();
          StopWatch_1.instance().stopTimer(timer);
      }
      
      // switch to role2 from role1
      for (int i = 0; i < num; i++) {
          StopWatch_1.instance().startTimer(timer = "switchSameRoles");
          unitOfWork.begin();
          role2Objects[i] = (RoleClassRoleA)role1Objects[i].getRole(role2);
          unitOfWork.commit();
          StopWatch_1.instance().stopTimer(timer);
      }
      
      // switch to role2
      for (int i = 0; i < num; i++) {
          StopWatch_1.instance().startTimer(timer = "getRole_" + role2);
          unitOfWork.begin();
          role2Objects[i] = (RoleClassRoleA)baseObjects[i].getRole(role2);
          unitOfWork.commit();
          StopWatch_1.instance().stopTimer(timer);
      }
      
      
      // switch to core
      for (int i = 0; i < num; i++) {
          StopWatch_1.instance().startTimer(timer = "switchToCore");
          unitOfWork.begin();
          baseObjects[i] = (RoleClass)role2Objects[i].getCore();
          unitOfWork.commit();
          StopWatch_1.instance().stopTimer(timer);
      }
      
      // get RoleType
      for (int i = 0; i < num; i++) {
          StopWatch_1.instance().startTimer(timer = "getRoleTypes");
          unitOfWork.begin();
          role2Objects[i].getRoleType();
          role1Objects[i].getRoleType();
          unitOfWork.commit();
          StopWatch_1.instance().stopTimer(timer);
      }          
      
      // remove objects for the other tests
      removeRoleClassesFromSegment();
      
      TSW.printOut("testPerformance", new PrintWriter(System.out, true));
        
      StringWriter buffer = new StringWriter();
      TSW.printOut("testPerformance", new PrintWriter(buffer, true));
      buffer.flush();
        
      AppLog.statistics("test", buffer.toString());
      AppLog.statistics("test", "test");
        
       
      // reset to standard
      StopWatch_1.setStopWatch(null);
  }
  

  /**
   * Test multiple qualifying attribute .
   * - all attributes must be treated unique
   * - access by all these attributes should be supported
   */
  public void testMultipleQualifyingAttributes(
  ) throws Exception {
      try {
          String idPrefix = "idMulti";
          
          String roleAName = idPrefix + "ra";
          String roleBName = idPrefix + "rb";
          
          String core1Id = idPrefix + "c1";
          String core2Id = idPrefix + "c2";

          // initialize testRole1 package
          //System.out.println("activating model...");
          Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
  
          // get segment singleton
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();

          
          RoleClassClass roleClassClass = 
              pkg.getRoleClass();
          RoleClassRoleARoleTypeClass roleARoleTypeClass = 
              pkg.getRoleClassRoleARoleType(); 
          RoleClassRoleAClass roleAClass = 
              pkg.getRoleClassRoleA();
          
          System.out.println(" create RoleTypes needed ...");
          try {
              RoleClassRoleARoleType roleType = null;
              roleType = roleARoleTypeClass.createRoleClassRoleARoleType();
              unitOfWork.begin();
              modelSegment.addAbstractRootRoleType(
                  roleAName,
                  roleType
              );
              unitOfWork.commit();
              unitOfWork.begin();
              roleType = roleARoleTypeClass.createRoleClassRoleARoleType();
              modelSegment.addAbstractRootRoleType(
                  roleBName,
                  roleType
              );
              unitOfWork.commit();
          }
//        catch (JmiServiceException je) {
          catch (Exception je) {
              if (unitOfWork.isActive()) {
                  unitOfWork.rollback();
              }
              if (!isDuplicateException(je)) {
                  throw je;
              }
          }
          
          // create cores
          unitOfWork.begin();
          RoleClass core1 = 
              roleClassClass.createRoleClass("nameValue 1", "rcNameValue");
          core1.getAaaa().add("aaaa");
          core1.getBbbb().add("bbbb");

          RoleClass core2 = 
              roleClassClass.createRoleClass("nameValue 2", "rcNameValue");
          core2.getAaaa().add("aaaa");
          core2.getBbbb().add("aaaa");
          
          modelSegment.addRoleAbstractRoot(core1Id, core1);
          
          modelSegment.addRoleAbstractRoot(core2Id, core2);
          unitOfWork.commit();

          // add a role to core1 

          // for RoleClassRoleA the qualifying attribute is rcraName, ident or id
          String rcraName = "rcraName1";
          String ident = "ident1";
          
          unitOfWork.begin();
          RoleClassRoleA roleA = 
              roleAClass.extendRoleClass(core1, rcraName);
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent(ident);
          core1.addRole(roleAName, roleA);
          unitOfWork.commit();
          
          unitOfWork.begin();
          roleA = roleAClass.extendRoleClass(core1, rcraName);
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent(ident);
          
          // adding to the other role should be ok:
          core1.addRole(roleBName, roleA);
          unitOfWork.commit();

          unitOfWork.begin();
          
          // try uniqueness on both attributes: rcraName and ident
          roleA = roleAClass.extendRoleClass(core2, rcraName);
          
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent(ident+ "differ");
          
          try {
              core2.addRole(roleAName, roleA);
              unitOfWork.commit();

              assertTrue(" expected exception: same rcraName value", false);
          }
//        catch(JmiServiceException se) {
//          this.assertException(
//            se.getExceptionStack(),
          catch(Exception se) {
            this.verifyException(
              se,
              BasicException.Code.DUPLICATE,
              null
            );
          }
          
          unitOfWork.begin();

          roleA = 
               roleAClass.extendRoleClass(core2, rcraName + "differ");
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent(ident);
          try {
              core2.addRole(roleAName, roleA);
              unitOfWork.commit();
              fail(" expected exception: same ident value");
          }
//        catch(JmiServiceException se) {
//          if(unitOfWork.isActive()) unitOfWork.rollback();
//          this.assertException(
//            se.getExceptionStack(),
          catch(Exception se) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
            this.verifyException(
              se,
              BasicException.Code.DUPLICATE,
              null
            );
          }

          // now try to access the object by the different ways:
          
          // first roleAIdent:
          unitOfWork.begin();

          RoleClassRoleARoleType roleAType = (RoleClassRoleARoleType)
              modelSegment.getAbstractRootRoleType(roleAName);
//            RoleClassRoleARoleType roleBType = (RoleClassRoleARoleType)
//                modelSegment.getAbstractRootRoleType(roleBName);
          
          ArrayList roleAFound = new ArrayList();
          roleA = roleAType.getRoleAIdent(ident);
          unitOfWork.commit();
          
          roleAFound.add(roleA);
          
          unitOfWork.begin();
          roleA = roleAType.getRoleClassRoleA(rcraName);
          unitOfWork.commit();
          roleAFound.add(roleA);
          
          unitOfWork.begin();
          roleA = roleAType.getRoleAId(core1Id);
          unitOfWork.commit();

          roleAFound.add(roleA);
          
          unitOfWork.begin();
          roleA = (RoleClassRoleA) 
              modelSegment.getRoleAbstractRoot(core1Id).getRole(roleAName);
          unitOfWork.commit();

          roleAFound.add(roleA);
          
          checkCountAndType(4, RoleClassRoleA.class, roleAFound);
          
          // what's the use of that test????
//            RoleClassRoleA last = null;
//            for (Iterator i = roleAFound.iterator(); i.hasNext(); ) {
//                RoleClassRoleA act = (RoleClassRoleA)i.next(); 
//                
//                if (last != null) { 
//                    compareDataproviderObjects(
//                        (DataproviderObject)last.refDelegate(), 
//                        (DataproviderObject)act.refDelegate()
//                    );
//                }
//                last = act;
//            }
          
          
          tearDownMultipleQualifyingAttributes(
              modelSegment, 
              new String[] {core1Id, core2Id}
          );
      }
//    catch (JmiServiceException se) {
      catch (Exception se) {
//        System.out.println("JmiServiceException: " + se.getMessage());
//        se.printStackTrace();
//        System.out.println(
//            "ServiceException: " +
//            se.getExceptionStack().getMessage()
//        );
//        se.getExceptionStack().printStackTrace();
          showException(se);
          throw se;
      }
  }



  
  public void testRoleInstancesInGroup(
  ) throws Exception {
      try {
          String idPrefix = "grp";
          
          String roleAName = idPrefix + "_ra";
          
          String core1Id = idPrefix + "_c1";
          String core2Id = idPrefix + "_c2";
          String noRoleId1 = idPrefix + "_1_nr";
          String noRoleId2 = idPrefix + "_2_nr";

          Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
  
          // get segment singleton
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();
         
          
          // need to delete objects to get clean db. Do it before start
          // to get the chance to have a look at the db
          System.out.println(" deleting the objects from db...");
          // just delete topmost and get rid of 
          try {
            unitOfWork.begin();
              modelSegment.removeRoleNoRole(noRoleId1);
            unitOfWork.commit();
          } catch (Exception e) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
          }
          try {
            unitOfWork.begin();
              modelSegment.removeRoleNoRole(noRoleId2);
            unitOfWork.commit();
          } catch (Exception e) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
          }
          try {
            unitOfWork.begin();
              modelSegment.removeRoleAbstractRoot(core1Id);
            unitOfWork.commit();
          } catch (Exception e) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
          }
          try {
            unitOfWork.begin();
              modelSegment.removeRoleAbstractRoot(core2Id);
            unitOfWork.commit();
          } catch (Exception e) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
          }
          
          
          RoleClassClass roleClassClass = 
              pkg.getRoleClass();
          RoleClassRoleARoleTypeClass roleARoleTypeClass = 
              pkg.getRoleClassRoleARoleType(); 
          RoleClassRoleAClass roleAClass = 
              pkg.getRoleClassRoleA();
          RoleNoRoleClass roleNoRoleClass = 
              pkg.getRoleNoRole();
              
          System.out.println(" create RoleTypes needed ...");
          RoleClassRoleARoleType roleType = null;
          try {
              roleType = roleARoleTypeClass.createRoleClassRoleARoleType();
              unitOfWork.begin();
              modelSegment.addAbstractRootRoleType(
                  roleAName,
                  roleType
              );
              unitOfWork.commit();
          }
//        catch (JmiServiceException je) {
          catch (Exception je) {
              if (unitOfWork.isActive()) {
                  unitOfWork.rollback();
              }
              if (!isDuplicateException(je)) {
                  throw je;
              }

//                if (je.getServiceException().getExceptionCode()
//                    != StackedException.DUPLICATE
//                ) {
//                    throw je;
//                }
              // must have it 
              roleType = (RoleClassRoleARoleType)
                  modelSegment.getAbstractRootRoleType(roleAName);
          }
          
          unitOfWork.begin();
          RoleNoRole roleNoRole1 = 
              roleNoRoleClass.createRoleNoRole("noRole 1111");
          roleNoRole1.getAaaa().add(0, "aaaa0000");
          
          modelSegment.addRoleNoRole(noRoleId1, roleNoRole1);
          unitOfWork.commit();

          unitOfWork.begin();
          RoleNoRole roleNoRole2 = 
              roleNoRoleClass.createRoleNoRole("noRole 2222");
          roleNoRole2.getAaaa().add("aaaa1111");
          
          modelSegment.addRoleNoRole(noRoleId2, roleNoRole2);
          unitOfWork.commit();
                   
          unitOfWork.begin();
          // create cores     
          RoleClass core1 = 
              roleClassClass.createRoleClass("name value 1", "rcName value 1");
          core1.getAaaa().add("aaaa1111");
          core1.getBbbb().add("bbbb1111");
          
          RoleClass core2 = 
              roleClassClass.createRoleClass("name value 2", "rcName value 2");
          core2.getAaaa().add("aaaa2222");
          core2.getBbbb().add("aaaa2222");
          
          modelSegment.addRoleAbstractRoot(core1Id, core1);
          
          modelSegment.addRoleAbstractRoot(core2Id, core2);
          unitOfWork.commit();


          // add a role to core1 

          // for RoleClassRoleA the qualifying attribute is rcraName, ident or id
          String rcraName1 = "rcraName1";
          String ident1 = "ident1";
          
          unitOfWork.begin();
          RoleClassRoleA roleA1 = 
              roleAClass.extendRoleClass(
                  core1,  
                  rcraName1
              );
          roleA1.setDddd(new String[] {"dddd1111"});
          roleA1.setIdent(ident1);
          core1.addRole(roleAName, roleA1);
          unitOfWork.commit();
          
          System.out.println(" add member to group ");
          
          
          // add first role to group 
          // roleNoRole.addMember(roleA1); // the wrong way
            unitOfWork.begin();
             
            roleA1.addGroup(roleNoRole1);
            
            roleA1.addGroup(roleNoRole2);
            unitOfWork.commit();
 
            
            /*
          List groups = 
              roleA1.getGroup(noRoleId);
          System.out.println("groups " + noRoleId + " in member :"+ groups.size());
          */
          // get the members of the group:
          unitOfWork.begin();
          Collection groupMembers = 
              roleNoRole1.getMember(roleType);
          unitOfWork.commit();
               
          assertTrue("expected 1 one member in group, got: " + groupMembers.size(),
              groupMembers.size() == 1);

          groupMembers = 
              roleNoRole2.getMember(roleType);
              
          assertTrue("expected 1 one member in group, got: " + groupMembers.size(),
              groupMembers.size() == 1);
          
          
          String rcraName2 = "rcraName2";
          String ident2 = "ident2";


          unitOfWork.begin();
          RoleClassRoleA roleA2 = 
              roleAClass.extendRoleClass(
                  core1,  
                  rcraName2
              );
          roleA2.setDddd(new String[] {"dddd1111"});
            roleA2.setIdent(ident2);
                 
            core2.addRole(roleAName, roleA2);
            unitOfWork.commit();
 
            unitOfWork.begin();
            roleA2.addGroup(roleNoRole1);

            groupMembers = 
                roleNoRole1.getMember(roleType);
            unitOfWork.commit();
                
            assertTrue("expected 2 one member in group, got: " + groupMembers.size(),
              groupMembers.size() == 2);
      }
      catch (Exception se) {
          showException(se);            
          throw se;
          
      }
  }           

          
  public void testRoleInstancesInSingleGroup(
  ) throws Exception {
      try {
          String idPrefix = "sgrp";
          
          String roleBName = idPrefix + "_rb";
          
          String core1Id = idPrefix + "_c1";
          String core2Id = idPrefix + "_c2";
          String noRoleId1 = idPrefix + "_1_nr";
          String noRoleId2 = idPrefix + "_2_nr";

          // initialize testRole1 package
          //System.out.println("activating model...");
          Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();

          pkg.refMetaObject();
          // System.out.println(" done");
          
  
          // get segment singleton
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();
          
          
          // need to delete objects to get clean db. Do it before start
          // to get the chance to have a look at the db
          System.out.println(" deleting the objects from db...");
          // just delete topmost and get rid of 
          
          
          try {
            unitOfWork.begin();
              modelSegment.removeRoleNoRole(noRoleId1);
            unitOfWork.commit();
          } catch (Exception e) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
          }
          try {
            unitOfWork.begin();
              modelSegment.removeRoleNoRole(noRoleId2);
            unitOfWork.commit();
          } catch (Exception e) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
          }
          try {
            unitOfWork.begin();
              modelSegment.removeRoleAbstractRoot(core1Id);
            unitOfWork.commit();
          } catch (Exception e) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
          }
          try {
            unitOfWork.begin();
              modelSegment.removeRoleAbstractRoot(core2Id);
            unitOfWork.commit();
          } catch (Exception e) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
          }
          
          
          RoleClassClass roleClassClass = 
              pkg.getRoleClass();
          RoleClassRoleBRoleTypeClass roleBRoleTypeClass = 
              pkg.getRoleClassRoleBRoleType(); 
          RoleClassRoleBClass roleBClass = 
              pkg.getRoleClassRoleB();
          RoleNoRoleClass roleNoRoleClass = 
              pkg.getRoleNoRole();
              
          System.out.println(" create RoleTypes needed ...");
          RoleClassRoleBRoleType roleType = null;
          try {
              roleType = roleBRoleTypeClass.createRoleClassRoleBRoleType();
              unitOfWork.begin();
              modelSegment.addAbstractRootRoleType(
                  roleBName,
                  roleType
              );
              unitOfWork.commit();
          }
//        catch (JmiServiceException je) {
          catch (Exception je) {
              if (unitOfWork.isActive()) {
                  unitOfWork.rollback();
              }
              if (!isDuplicateException(je)) {
                  throw je;
              }
              // must have it 
              roleType = (RoleClassRoleBRoleType)
                  modelSegment.getAbstractRootRoleType(roleBName);
          }
              
          RoleNoRole roleNoRole1 = 
              roleNoRoleClass.createRoleNoRole("noRole 1111");
          roleNoRole1.getAaaa().add("aaaa0000");
          unitOfWork.begin();
          modelSegment.addRoleNoRole(noRoleId1, roleNoRole1);
          unitOfWork.commit();
          RoleNoRole roleNoRole2 = 
              roleNoRoleClass.createRoleNoRole("noRole 2222");
          roleNoRole2.getAaaa().add("aaaa1111");
          unitOfWork.begin();
          modelSegment.addRoleNoRole(noRoleId2, roleNoRole2);
          unitOfWork.commit();
          
          // create cores     
          RoleClass core1 = 
              roleClassClass.createRoleClass("name value 1", "rcName value 1");
          unitOfWork.begin();
          core1.getAaaa().add("aaaa1111");
          core1.getBbbb().add("bbbb1111");
          core1.setRoleBId("roleBId1");
          unitOfWork.commit();

          RoleClass core2 = 
              roleClassClass.createRoleClass("name value 2", "rcName value 2");
          core2.getAaaa().add("aaaa2222");
          core2.getBbbb().add("aaaa2222");
          core2.setRoleBId("roleBId2");
          unitOfWork.begin();
          modelSegment.addRoleAbstractRoot(core1Id, core1);
          
          modelSegment.addRoleAbstractRoot(core2Id, core2);
          unitOfWork.commit();

          // add a role to core1 

          // for RoleClassRoleA the qualifying attribute is rcraName, ident or id
          String rcrbName1 = "rcrbName1";
          //String ident1 = "ident1";
          
          unitOfWork.begin();

          RoleClassRoleB roleB1 = 
              roleBClass.extendRoleClass(
                  core1,  
                  rcrbName1
              );
          roleB1.setFfff(new String[] {"ffff1111"});
               
          core1.addRole(roleBName, roleB1);
          unitOfWork.commit();

          unitOfWork.begin();
          String rcrbName2 = "rcrbName2";
          RoleClassRoleB roleB2 = 
              roleBClass.extendRoleClass(
                  core2, 
                  rcrbName2
              );
          roleB2.setFfff(new String[] {"ffff2222"});

          core2.addRole(roleBName, roleB2);
          unitOfWork.commit();

          System.out.println(" add member to group ");
          
          unitOfWork.begin();
          // try setting the group on the roleB2
          roleB2.setNoRole(roleNoRole2);
          unitOfWork.commit();

          
          // try adding the roleB1 to its group            
          // It can't work because the access from the rolteype to the role 
          // instances is frozen ( and this has its own reason??). 
          // there should be a model constraint requireing the reference to 
          // be frozen.
          // roleNoRole1.addRoleB(roleB1);
          //  roleNoRole1.refCommit();
          
          unitOfWork.begin();
          Collection groupMembers = roleNoRole1.getRoleB(roleType);

          assertTrue("expected 0 member in group, got: " + groupMembers.size(),
              groupMembers.size() == 0);
          unitOfWork.commit();
          
          unitOfWork.begin();
          groupMembers = 
              roleNoRole2.getRoleB(roleType);
              
          assertTrue("expected 1 member in group, got: " + groupMembers.size(),
              groupMembers.size() == 1);
          unitOfWork.commit();

          unitOfWork.begin();
          RoleNoRole noRole = roleB2.getNoRole();
          assertTrue("expected RoleNoRole1, got:" + noRole,
              noRole != null && noRole.getAaaa(0).equals(roleNoRole2.getAaaa(0)));
          
          // adding the same roleB2 to another group
          roleB2.setNoRole(roleNoRole1);
          unitOfWork.commit();

          unitOfWork.begin();
          groupMembers = 
              roleNoRole1.getRoleB(roleType);
          unitOfWork.commit();

          assertTrue("expected 1 member in group, got: " + groupMembers.size(),
              groupMembers.size() == 1);

          unitOfWork.begin();
          groupMembers = 
              roleNoRole2.getRoleB(roleType);
          unitOfWork.commit();

              
          assertTrue("expected 0 member in group, got: " + groupMembers.size(),
              groupMembers.size() == 0);
          unitOfWork.begin();
          noRole = roleB2.getNoRole();
          assertTrue("expected RoleNoRole1, got:" + noRole,
              noRole != null && noRole.getAaaa(0).equals(roleNoRole1.getAaaa(0)));
          
          
          // set second role to same group
          roleB1.setNoRole(roleNoRole1);
          unitOfWork.commit();

          unitOfWork.begin();
          groupMembers = roleNoRole1.getRoleB(roleType);
          
          assertTrue("expected 2 member in group, got: " + groupMembers.size(),
              groupMembers.size() == 2);

          groupMembers = roleNoRole2.getRoleB(roleType);
              
          assertTrue("expected 0 member in group, got: " + groupMembers.size(),
              groupMembers.size() == 0);
          unitOfWork.commit();

          unitOfWork.begin();
          noRole = roleB2.getNoRole();
          assertTrue("expected RoleNoRole1, got:" + noRole,
              noRole != null && noRole.getAaaa(0).equals(roleNoRole1.getAaaa(0)));
          
          noRole = roleB1.getNoRole();
          assertTrue("expected RoleNoRole1, got:" + noRole,
              noRole != null && noRole.getAaaa(0).equals(roleNoRole1.getAaaa(0)));
          unitOfWork.commit();

          // check setting to null on roleB2,
          // --> does not work, see workaround in #0000657
          
      }
//        catch (JmiServiceException se) {
          catch (Exception se) {
//        System.out.println("JmiServiceException: " + se.getMessage());
          se.printStackTrace();
//        System.out.println(
//            "ServiceException: " + 
//            se.getExceptionStack().getMessage()
//        );
//        se.getExceptionStack().printStackTrace();
          throw se;
          
      }
  }     


  public void testRoleTypesQualifyingAttribute(
  ) throws Exception {
      try {
          String idPrefix = "idRTQA";
          String[] roleATypeNames = new String[2];
          String[] roleBTypeNames = new String[2];
          int roleTypeCount = 2;
          roleATypeNames[0] = idPrefix + "ra1";
          roleATypeNames[1] = idPrefix + "ra2";
          
          roleBTypeNames[0] = idPrefix + "rb1";
          roleBTypeNames[1] = idPrefix + "rb2";
          

          String coreA1Id = idPrefix + "_ctA1"; // create test
          String coreA2Id = idPrefix + "_ctA2";
          String coreB1Id = idPrefix + "_ctB1"; // create test
          String coreB2Id = idPrefix + "_ctB2";

          RoleClassRoleARoleType[] roleATypes = new RoleClassRoleARoleType[2];
          RoleClassRoleBRoleType[] roleBTypes = new RoleClassRoleBRoleType[2];

          String roleAroleATypeName = idPrefix + "rara1";
          RoleClassRoleARoleARoleType roleAroleAroleType = null;
          
          
          // initialize testRole1 package
          //System.out.println("activating model...");
          Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
  
          // get segment singleton
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();
          
          // need to delete objects to get clean db. Do it before start
          // to get the chance to have a look at the db
          System.out.println(" deleting the objects from db...");
          // just delete topmost and get rid of 
          String[] ROLE_ABSTRACT_ROOTS = new String[]{
            coreA1Id, coreA2Id, coreB1Id, coreB2Id
          };
          for (int i = 0; i < ROLE_ABSTRACT_ROOTS.length; i++) try {
            unitOfWork.begin();
                modelSegment.removeRoleAbstractRoot(ROLE_ABSTRACT_ROOTS[i]);
            unitOfWork.commit();
//        } catch (JmiServiceException exception){
          } catch (Exception exception){
            if(unitOfWork.isActive()) unitOfWork.rollback();           
            assertTrue(
                "NOT_FOUND excpetion expected instead of " + exception,
                isNotFoundException(exception)
            );
          }
//      TODO: Verify whether it is correct to comment out the following statements due to the NOT_SUPPORTED 
//            exception "Removal of RoleType is not supported. It may still be in use in role objects." 
//        for (int i = 0; i < roleTypeCount; i++) try {
//          unitOfWork.begin();
//            modelSegment.removeAbstractRootRoleType(roleATypeNames[i]);
//          unitOfWork.commit();
//        } catch (JmiServiceException exception){
//          if(unitOfWork.isActive()) unitOfWork.rollback();           
//          assertTrue(
//              "NOT_FOUND excpetion expected instead of " + exception,
//              isNotFoundException(exception)
//          );
//        }
//        for (int i = 0; i < roleTypeCount; i++) try {
//          unitOfWork.begin();
//            modelSegment.removeAbstractRootRoleType(roleBTypeNames[i]);
//          unitOfWork.commit();
//        } catch (JmiServiceException e){
//          if(unitOfWork.isActive()) unitOfWork.rollback();           
//          assertTrue(
//            "NOT_FOUND excpetion expected instead of " + exception,
//            isNotFoundException(exception)
//          );
//        }
//        try {
//          unitOfWork.begin();
//            modelSegment.removeAbstractRootRoleType(roleAroleATypeName);
//          unitOfWork.commit();
//        } catch (JmiServiceException e){
//          if(unitOfWork.isActive()) unitOfWork.rollback();           
//          assertTrue(
//            "NOT_FOUND excpetion expected instead of " + exception,
//            isNotFoundException(exception)
//          );
//        } 
            
          RoleClassClass roleClassClass = 
              pkg.getRoleClass();
          RoleClassRoleARoleTypeClass roleARoleTypeClass = 
              pkg.getRoleClassRoleARoleType(); 
          RoleClassRoleBRoleTypeClass roleBRoleTypeClass = 
              pkg.getRoleClassRoleBRoleType();
          RoleClassRoleARoleARoleTypeClass roleAroleARoleTypeClass = 
              pkg.getRoleClassRoleARoleARoleType();           
          RoleClassRoleAClass roleAClass = 
              pkg.getRoleClassRoleA();
          RoleClassRoleBClass roleBClass = 
              pkg.getRoleClassRoleB();
          
          System.out.println(" create RoleTypes needed ...");
          try {
              for (int i = 0; i < roleTypeCount; i++) {
                  System.out.println("    " + roleATypeNames[i] +"...");
              
                  RoleClassRoleARoleType roleType = 
                      roleARoleTypeClass.createRoleClassRoleARoleType();
                  roleATypes[i] = roleType;
                  try {
                    unitOfWork.begin();
                      modelSegment.addAbstractRootRoleType(
                          roleATypeNames[i],
                          roleType
                      );
                      unitOfWork.commit();
//                } catch (JmiServiceException exception) {
                  } catch (Exception exception) {
                    if(unitOfWork.isActive()) unitOfWork.rollback();
                    assertTrue(
                        "DUPLICATE exception expected instead of " + exception,
                        isDuplicateException(exception)
                    );
                  }
                  System.out.println("    " + roleBTypeNames[i] +"...");
              
                  RoleClassRoleBRoleType roleBType = 
                      roleBRoleTypeClass.createRoleClassRoleBRoleType();
                  roleBTypes[i] = roleBType;
                  unitOfWork.begin();
                  modelSegment.addAbstractRootRoleType(
                      roleBTypeNames[i],
                      roleBType
                  );
                  unitOfWork.commit();
                  // System.out.println(" ... done ");
              }
              
              roleAroleAroleType = roleAroleARoleTypeClass.createRoleClassRoleARoleARoleType();
              roleAroleAroleType.setCoreRole(roleATypeNames[0]);
              unitOfWork.begin();
              modelSegment.addAbstractRootRoleType(
                  roleAroleATypeName,
                  roleAroleAroleType
              );
              unitOfWork.commit();
          }
//        catch (JmiServiceException je) {
          catch (Exception je) {
              if (unitOfWork.isActive()) {
                  unitOfWork.rollback();
              }
              if (!isDuplicateException(je)) {
                  throw je;
              }
              else {
                  // need the role types
                          for (int i = 0; i < roleTypeCount; i++) {
                      roleATypes[i] = (RoleClassRoleARoleType)
                                      modelSegment.getAbstractRootRoleType(roleATypeNames[i]);
                            
                      roleATypes[i] = (RoleClassRoleARoleType) 
                          modelSegment.getAbstractRootRoleType(roleATypeNames[i]);
                  }
                  roleAroleAroleType = (RoleClassRoleARoleARoleType)
                      modelSegment.getAbstractRootRoleType(roleAroleATypeName);
              }
          }        
      
      
          // 
          // create
          // 
          // creation through role type must not be supported 
          // (really it is impossible because the core object is unknown)
          // but we must assert uniqueness of the the defined qualifier 
          // attributes.
          
          // ####
          System.out.println(" create roleA object with existing id (must throw exception) ...");

          unitOfWork.begin();
          RoleClass core1 = 
              roleClassClass.createRoleClass(
                  "nameValue",
                  "rcNameValue"
              );
          core1.getAaaa().add("aaaa");
          core1.getBbbb().add("aaaa");
          
          RoleClass core2 = roleClassClass.createRoleClass(
                  "nameValue",
                  "rcNameValue"
              );
          
          core2.getAaaa().add("aaaa");
          core2.getBbbb().add("aaaa");
                         
          modelSegment.addRoleAbstractRoot(
              coreA1Id,
              core1
          );
          
          modelSegment.addRoleAbstractRoot(
              coreA2Id,
              core2
          );
          unitOfWork.commit();

          System.out.println(" add roleA to core1 ...");

          // for RoleClassRoleA the qualifying attribute is rcraName
          String rcraName = "rcraName1";
          
          unitOfWork.begin();
          RoleClassRoleA roleA = 
              roleAClass.extendRoleClass(
                  core1,  
                  rcraName
              );
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent("ident1");
          
          core1.addRole(roleATypeNames[0], roleA);
          unitOfWork.commit();

          System.out.println(" add roleA with same qualifying attribute to another core (exception!) ...");
          unitOfWork.begin();
          roleA = 
              roleAClass.extendRoleClass(
                  core2,  
                  rcraName
              );
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent("ident2");
          try {
              core2.addRole(roleATypeNames[0], roleA);
              unitOfWork.commit();
              assertTrue(" expected exception because qualifying attribute exists", false);
          }
//        catch(JmiServiceException se) {
//          this.verifyException(
//            se.getExceptionStack(),
          catch(Exception se) {
            if(unitOfWork.isActive()) unitOfWork.rollback();
            this.verifyException(
              se,
              BasicException.Code.DUPLICATE,
              null
            );
          }
          //unitOfWork.commit();
          
          unitOfWork.begin();
          roleA = roleAClass.extendRoleClass(
            core2,  
            rcraName
          );
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent("ident3");
          
          // adding the same to another role should work
          System.out.println(" use the same qualifying attribute in another role  ...");            
          core2.addRole(roleATypeNames[1], roleA);
          unitOfWork.commit();
          
          System.out.println(" add roleA with another qualifying attribute ...");
          unitOfWork.begin();
          roleA = 
              roleAClass.extendRoleClass(
                  core2,  
                  "someValueNotUsed"
              );
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent("ident4");
          // now add 
          core2.addRole(roleATypeNames[0], roleA);
          unitOfWork.commit();

          
          System.out.println(" now try to change the value of qualifying attribute to existing ...");
          unitOfWork.begin();
          roleA = (RoleClassRoleA) core2.getRole(roleATypeNames[0]);
          try {
            roleA.setRcraName(rcraName);
            unitOfWork.commit();
            fail("expected exception because of invalid value for qualifying attribute");
          }
//        catch(JmiServiceException se) {
//          this.verifyException(
//            se.getExceptionStack(),
          catch(Exception se) {
            this.verifyException(
              se,
              BasicException.Code.DUPLICATE,
              null
            );
          }

          // roleAroleA uses the same qualifying attribute but may only be extended
          // on a existing roleA ... (no tests here)


          // it is not allowed for those qualifying attributes th have "/" at
          // the start or at the end. This is because those values can be used
          // in a path (what we did above). With "/" at the end or at the 
          // beginning the escape sequence looks like "///" (one slash from 
          // the path) and on resolving this, one slash can't be determined.
          
          System.out.println(" try creating qualifying attribute with invalid value ...");
          rcraName = "/rcraName2";
          unitOfWork.begin();
          roleA = 
              roleAClass.extendRoleClass(
                  core2,  
                  rcraName
              );
          roleA.setDddd(new String[] {"dddd"});
          roleA.setIdent("ident5");
          try {
            core2.addRole(roleATypeNames[0], roleA);
            unitOfWork.commit();
            fail("expected exception because of invalid value for qualifying attribute");
          }
//        catch(JmiServiceException se) {
//          this.verifyException(
//            se.getExceptionStack(),
          catch(Exception se) {
//          this.verifyException(
//            se.getStackedException(),
//            StackedException.ASSERTION_FAILURE,
//            null
//          );
            if(unitOfWork.isActive()) unitOfWork.rollback();
            assertTrue(
                "DUPLICATE exception excpected instead of " + se,
                isDuplicateException(se)
            );
          }
          
          // ####
          System.out.println(" create core for roleB tests ...");
          String qualiVal = "coreQuali_1";
          
          unitOfWork.begin();
          RoleClass core3 = 
              roleClassClass.createRoleClass();
          core3.setAaaa(new String[] { "aaaa", "b test" });
          core3.setName("nameValue");
          core3.setBbbb(new String[] { "bbbb" });
          core3.setRcName("rcNameValue");
          core3.setRoleBId(qualiVal);
              
          modelSegment.addRoleAbstractRoot(
              coreB1Id,
              core3
          );
          unitOfWork.commit();

          System.out.println(" add role to roleB core ...");
          // for RoleClassRoleB the qualifying attribute is refBId
          unitOfWork.begin();
          RoleClassRoleB roleB = 
              roleBClass.extendRoleClass(
                  core3, 
                  "bname"
              );
          core3.addRole(roleBTypeNames[0], roleB);
          unitOfWork.commit();

          System.out.println(" create core empty spec attribute  ...");
          
          unitOfWork.begin();
          RoleClass core4 = 
              roleClassClass.createRoleClass(
                  "name2Value",
                  "rcNameValue2"
              );
              core4.getAaaa().add(0, "a2a2");
              core4.getBbbb().add(0, "b2b2");
          modelSegment.addRoleAbstractRoot(
              coreB2Id,
              core4
          );
          unitOfWork.commit();
          
          System.out.println(" try adding role to core with emtpy spec attribute (exception) ...");
          // for RoleClassRoleB the qualifying attribute is refBId
          unitOfWork.begin();
          roleB = 
              roleBClass.extendRoleClass(
                  core4,  
                  "b2name"
              );
          try {
              core4.addRole(roleBTypeNames[1], roleB);
              unitOfWork.commit();
          }
//        catch(JmiServiceException se) {
//          this.verifyException(
//            se.getExceptionStack(),
          catch(Exception se) {
            this.verifyException(
              se,
              BasicException.Code.ASSERTION_FAILURE,
              null
            );
          }
          
          System.out.println(" update core with existing qualifying value (exception) ...");
          unitOfWork.begin();
          core4.setRoleBId(qualiVal);
          
          // for RoleClassRoleB the qualifying attribute is refBId
          roleB = roleBClass.extendRoleClass(
            core4,  
            "b2name"
          );
          try {
            core4.addRole(roleBTypeNames[1], roleB);
            unitOfWork.commit();
          }
//        catch(JmiServiceException se) {
//          this.verifyException(
//            se.getExceptionStack(),
          catch(Exception se) {
//           this.verifyException(
//              se.getStackedException(),
//              StackedException.ASSERTION_FAILURE,
//              null
//          );
            if(unitOfWork.isActive()) unitOfWork.rollback();
            assertTrue(
                "DUPLICATE exception excpected instead of " + se,
                isDuplicateException(se)
            );
          }

          // tbd try changing value of core's qualifying attribute to 
          // exsiting value for a core that already has the role. 
            
            
 
        }
        catch (Exception se) {
            showException(se);            
            throw se;
        }    
    }
    
    
    public void testFindContinuation(
    ) throws Exception {
        // this test may only run if the db is present
      ArrayList roleClassList = new ArrayList();
      ArrayList roleNameList = new ArrayList();
      
      String roleClassIdBase = "tfi";
      // String roleAIdBase = "tfiRA";
      int roleClassNum = 20;
      int roleANum = 3;
      
      try { // catch for JmiServiceException
                       // initialize testRole1 package
          //System.out.println("activating model...");
          Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
  
          // get segment singleton
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();
          
          // need to delete objects to get clean db. Do it before start
          // to get the chance to have a look at the db
          System.out.println(" deleting the objects from db...");
          // just delete topmost and get rid of roles 
          for (int i = 0; i < roleClassNum; i++) try {
            System.err.println("Removing " + roleClassIdBase + String.valueOf(i));                                      
            unitOfWork.begin();
              modelSegment.removeRoleAbstractRoot(roleClassIdBase + i);
            unitOfWork.commit();
//        } catch (JmiServiceException e){
          } catch (Exception e){
             if(unitOfWork.isActive()) unitOfWork.rollback();
          }

//      TODO: Verify whether it is correct to comment out the following statements due to the NOT_SUPPORTED 
//            exception "Removal of RoleType is not supported. It may still be in use in role objects." 
//          for (int i = 0; i < roleANum; i++) try {
//          unitOfWork.begin();
//              modelSegment.removeAbstractRootRoleType(roleClassIdBase + "ra" + i);
//          unitOfWork.commit();
//        } catch (JmiServiceException e){
//          if(unitOfWork.isActive()) unitOfWork.rollback();           
//        }
          
          System.out.println(" create RoleTypes needed ...");

          RoleClassRoleARoleTypeClass roleARoleTypeClass =
              pkg.getRoleClassRoleARoleType();

          System.out.println("    " + roleClassIdBase + "raX...");

          for (int i = 0; i < roleANum; i++) {
              String roleName = roleClassIdBase + "ra" + i;
              try {
                  unitOfWork.begin();
                  modelSegment.addAbstractRootRoleType(
                      roleName,
                      roleARoleTypeClass.createRoleClassRoleARoleType());
                  unitOfWork.commit();
//            } catch (JmiServiceException je) {
              } catch (Exception je) {
                if(unitOfWork.isActive()) unitOfWork.rollback();
                if (!isDuplicateException(je)) throw je;
              }
              roleNameList.add(roleName);
          }
          
          System.out.println(" create the RoleClass objects ...");
          RoleClassClass roleClassClass = pkg.getRoleClass();
          RoleClassRoleAClass roleAClass = pkg.getRoleClassRoleA();
          for (int i = 0; i < roleClassNum; i++) {
              unitOfWork.begin();
              String roleClassId = String.valueOf(i);
              RoleClass roleClass = 
                  roleClassClass.createRoleClass(
                      "nameValue of " + roleClassId,
                      "rcNameValue of " + roleClassId
                  );
              roleClass.setAaaa(new String[] {roleClassId, "a string values" });
              roleClass.setBbbb(new String[] {roleClassId, "b string values"});
              
              modelSegment.addRoleAbstractRoot(
                  roleClassIdBase + roleClassId,
                  roleClass
              );
              unitOfWork.commit();
              roleClassList.add(roleClass);
          }
          
          System.out.println(" add the roles ...");
          for (int i = 0; i < roleClassNum; i++) {
              System.out.println("extending roleClass: " 
                  + ((RoleClass)roleClassList.get(i)).getIdentity());
              for (int r = 0; r < roleANum; r++) {
                  System.out.print(i + ","+ r + ", ");
                  System.out.flush();
                  unitOfWork.begin();
                  RoleClassRoleA roleA = 
                      roleAClass.extendRoleClass(
                          (RoleClass)roleClassList.get(i),
                          "rcraNameValue of object " + i + " role " + r
                      );
                  roleA.setDddd(
                      new String[] {
                              String.valueOf(i), 
                              String.valueOf(r), 
                              "dValue", 
                              String.valueOf(i % (r+2))
                      }
                  );
                  roleA.setIdent("ident6_" + String.valueOf((i*roleANum) + r));
//                  unitOfWork.commit();
//                  unitOfWork.begin();
                  ((RoleClass)roleClassList.get(i)).
                      addRole(((String)roleNameList.get(r)), roleA);
                  Date start = new Date();
                  unitOfWork.commit();
                  Date end = new Date();
                  System.out.println("commit took: " + (end.getTime() - start.getTime()));
              }
              System.out.println("");
          }

          // now we have some objects with some roles.
          System.out.println(" find the roles ...");
          
          RoleClassRoleAQuery roleQuery = pkg.createRoleClassRoleAQuery();
          
          roleQuery.thereExistsObject_inRole().equalTo((String)roleNameList.get(1));
          // List results = modelSegment.getRoleAbstractRoot(roleQuery);
          unitOfWork.begin();
          Container results = (Container) modelSegment.getRoleAbstractRoot();
          results = results.subSet(roleQuery);
                     
          assertEquals(
            "Result size",
            roleClassNum,
            results.size()
          );
          unitOfWork.commit();
          
          System.out.println(" try a somewhat more complex filter ... ");
          roleQuery.thereExistsDddd().equalTo("2");
          //results = modelSegment.getRoleAbstractRoot(roleQuery);
          unitOfWork.begin();
          results = (Container) modelSegment.getRoleAbstractRoot();
          results = results.subSet(roleQuery);
          
          // get all the objects
          for (Iterator l = results.iterator();
              l.hasNext(); 
          ) {
              l.next();
          }
          assertTrue(
              "expected "  + roleClassNum / roleANum + 
              " objects to be found, there were " + results.size(),
              results.size() == (roleClassNum / roleANum )
          );
          unitOfWork.commit();

          
          
          System.out.println(" try a find on the cores ... ");
          RoleClassQuery roleClassQuery = pkg.createRoleClassQuery();
          roleClassQuery.thereExistsObject_inRole().equalTo((String)roleNameList.get(1));

          //results = modelSegment.getRoleAbstractRoot(roleClassQuery);      
          unitOfWork.begin();     
          results = (Container) modelSegment.getRoleAbstractRoot();
          results = results.subSet(roleClassQuery);
          checkCountAndType(roleClassNum, RoleClass.class, results);
          unitOfWork.commit();

      }
      catch (Exception se) {
          showException(se);
          throw se;
          
      } 
  }



  //---------------------------------------------------------------------------    
  /**
   * Testing iteration over the roles of an object.
   */
  public void testRoleIteration(
  ) throws Exception {
      try {
           // initialize testRole1 package
          //System.out.println("activating model...");
          Role1Package pkg = createRole1Package(new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          PersistenceManager persistenceManager = ((RefPackage_1_1)pkg).refPersistenceManager(); 
          Transaction unitOfWork = persistenceManager.currentTransaction();
  
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();
          
          String oid1 = "roleIter1";  // id of the object
          String oid2 = "roleIter2";
           
          String rid1 = "role1";      // id of roles
          String rid2 = "role2";
          String rid3 = "role3";
          String rid4 = "role4";
          
          try {
              unitOfWork.begin();
              // need to delete objects to get clean db. Do it before start
              // to get the chance to have a look at the db
              System.out.println(" deleting the objects from db...");
              // just delete topmost and get rid of 
              modelSegment.removeRoleAbstractRoot(oid1);
              modelSegment.removeRoleAbstractRoot(oid2);
              // now the roletypes:
              modelSegment.removeAbstractRootRoleType(rid1);
              modelSegment.removeAbstractRootRoleType(rid2);

              modelSegment.removeAbstractRootRoleType(rid3);
              modelSegment.removeAbstractRootRoleType(rid4);
              unitOfWork.commit();
          }
          catch (Exception e) {
            if (unitOfWork.isActive()) {
                unitOfWork.rollback();
            }
          }
   
          System.out.println(" create objects ...");
          RoleClassClass roleClassClass = pkg.getRoleClass();
          
          RoleClass roleClass1 =
              roleClassClass.createRoleClass(oid1, "rcNameValue");

          RoleClass roleClass2 =
              roleClassClass.createRoleClass(oid2, "rcNameValue");

          unitOfWork.begin();
          modelSegment.addRoleAbstractRoot(oid1, roleClass1);

          modelSegment.addRoleAbstractRoot(oid2, roleClass2);
          unitOfWork.commit();

          
          System.out.println(" create RoleTypes ...");
          try {
              unitOfWork.begin();
              // RoleClassRoleA
              RoleClassRoleARoleTypeClass roleARoleTypeClass =
                  pkg.getRoleClassRoleARoleType();

              modelSegment.addAbstractRootRoleType(
                  rid1,
                  roleARoleTypeClass.createRoleClassRoleARoleType());

              modelSegment.addAbstractRootRoleType(
                  rid2,
                  roleARoleTypeClass.createRoleClassRoleARoleType());
              
              // RoleClassRoleB
              RoleClassRoleBRoleTypeClass roleBRoleTypeClass =
                  pkg.getRoleClassRoleBRoleType();

              modelSegment.addAbstractRootRoleType(
                  rid3,
                  roleBRoleTypeClass.createRoleClassRoleBRoleType());
              
              // RoleClassRoleARoleA
              RoleClassRoleARoleARoleTypeClass roleARoleARoleTypeClass =
                  pkg.getRoleClassRoleARoleARoleType();
              
              RoleClassRoleARoleARoleType roleClassRoleARoleARoleType =
                  roleARoleARoleTypeClass.createRoleClassRoleARoleARoleType();
              roleClassRoleARoleARoleType.setCoreRole(rid1);
              modelSegment.addAbstractRootRoleType(
                  rid4,
                  roleClassRoleARoleARoleType);

              unitOfWork.commit();
          }
//        catch (JmiServiceException je) {
          catch (Exception je) {
              if (isDuplicateException(je)) {
                  if(unitOfWork.isActive()) unitOfWork.rollback();
              } else {
                  throw je;
              }
          }
         
          System.out.println(" add a roles to roleClasses ...."); 
          RoleClassRoleAClass roleAClass = pkg.getRoleClassRoleA();
          RoleClassRoleBClass roleBClass = pkg.getRoleClassRoleB();

          unitOfWork.begin();
          RoleClassRoleA roleA1 = 
              roleAClass.extendRoleClass(roleClass1, rid1 + "_" + oid1);
          roleA1.setIdent("AAAA");            
          roleClass1.addRole(rid1, roleA1);
          unitOfWork.commit();

          unitOfWork.begin();
          RoleClassRoleA roleA2 = 
              roleAClass.extendRoleClass(roleClass1, rid2 + "_" + oid1);
          roleA2.setIdent("BBBB");            
          roleClass1.addRole(rid2, roleA2);
          unitOfWork.commit();
          
          unitOfWork.begin();            
          RoleClassRoleB roleB = 
              roleBClass.extendRoleClass(roleClass1, rid3 + "_" + oid1);
          roleClass1.setRoleBId(oid1);
          roleClass1.addRole(rid3, roleB);
          unitOfWork.commit();

          RoleClassRoleARoleAClass roleARoleAClass = 
              pkg.getRoleClassRoleARoleA();

          unitOfWork.begin();
          RoleClassRoleARoleA roleARoleA = 
              roleARoleAClass.extendRoleClassRoleA(roleA1,  rid4 + "_" + oid1);
          roleA1.addRole(rid4, roleARoleA);
          unitOfWork.commit();

          // prepare expected result sets
          Set allRoleNames = new HashSet();
          allRoleNames.add(rid1);
          allRoleNames.add(rid2);
          allRoleNames.add(rid3);
          allRoleNames.add(rid4);
          
          List remainingInRoles = new ArrayList();
          Set roles = new HashSet(); roles.add(rid1);
          remainingInRoles.add(roles);
          roles = new HashSet(); roles.add(rid2);
          remainingInRoles.add(roles);
          roles = new HashSet(); roles.add(rid3);
          remainingInRoles.add(roles);
          roles = new HashSet(); roles.add(rid1); roles.add(rid4);
          remainingInRoles.add(roles);
          
          System.out.println(" start iteration over roles ...");
             
          Collection objRoles = roleClass1.getRole();
          for (Iterator r = objRoles.iterator(); r.hasNext();) {
              RoleClass rc = (RoleClass) r.next();
              
              // refresh() can't be removed unless rc is part of (at least the last) unit of work
              persistenceManager.refresh(rc);
              
              assertEquals(
                  "hasRole must contain all roles",
                  allRoleNames,
                  rc.getObject_hasRole()
              );

              assertTrue(
                  "expected role to be instance of "
                      + "RoleClassRoleA, RoleClassRoleB or RoleClassRoleARoleA, "
                      + "but it is: "
                      + rc.getClass().getName(),
                  rc instanceof RoleClassRoleA
                      || rc instanceof RoleClassRoleB
                      || rc instanceof RoleClassRoleARoleA);
              
              Set currentRoles = new HashSet(rc.getObject_inRole());
              assertTrue(
                  "inRoles of the object: " + currentRoles + " are not contained in the expected roles: " + remainingInRoles,
                  remainingInRoles.remove(currentRoles));
          } 
          
          assertEquals("number of roles", 4, objRoles.size());
          
          assertTrue("result set was not in all roles; remaining: "+  remainingInRoles,
            remainingInRoles.size() == 0
          );
          
          System.out.println(" try iterating object without roles ...");
         
          objRoles = roleClass2.getRole();
          assertEquals("number of roles", 0, objRoles.size());
          
          System.out.println(" try iterating object with filter (--> exception)...");
          
          // get exceptions with filters
          Container objRolesContainer = (Container) roleClass1.getRole();
          
          RoleAbstractRootQuery hasRoleQuery = pkg.createRoleAbstractRootQuery();
          hasRoleQuery.forAllObject_hasRole().equalTo(rid1);
          
          try {
              objRolesContainer = objRolesContainer.subSet(hasRoleQuery);
              objRolesContainer.iterator().next(); // must access it for exception
              
              fail("exception expected");
          } catch (NoSuchElementException nse) {
          }
                      
          objRolesContainer = (Container) roleClass1.getRole();
          RoleAbstractRootQuery nameQuery = pkg.createRoleAbstractRootQuery();
          nameQuery.name().like("some string"); 
          try {
              objRolesContainer = objRolesContainer.subSet(nameQuery);
              objRolesContainer.iterator().next(); // must access it for exception
              fail("exception expected");
          } catch (NoSuchElementException nse) {
          }
                  
      }
      catch (Exception se) {
          showException(se);
          throw se;
      } 
  }


  //---------------------------------------------------------------------------    
  public void testAggregationInRole(
  ) throws Exception {
      try {
           // initialize testRole1 package
          //System.out.println("activating model...");
          Role1Package pkg = createRole1Package( new ServiceHeader(), AbstractTestRoleJmi_1.connection);
          Transaction unitOfWork = ((RefPackage_1_1)pkg).refPersistenceManager().currentTransaction();
  
          // get segment singleton
          SegmentClass modelSegmentClass = pkg.getSegment();
          unitOfWork.begin();
          Segment modelSegment = modelSegmentClass.getSegment(rootSegment);
          unitOfWork.commit();

          try {
              unitOfWork.begin();
              // need to delete objects to get clean db. Do it before start
              // to get the chance to have a look at the db
              System.out.println(" deleting the objects from db...");
              // just delete topmost and get rid of 
              modelSegment.removeRoleAbstractRoot("id1");
              // now the roletypes:
              modelSegment.removeAbstractRootRoleType("rara1");
              modelSegment.removeAbstractRootRoleType("rara2");
              
              modelSegment.removeAbstractRootRoleType("ra1");
              modelSegment.removeAbstractRootRoleType("ra2");
              unitOfWork.commit();
          }
          catch (Exception e) {
              if (unitOfWork.isActive()) {
                  unitOfWork.rollback();
              }
          }
   
          System.out.println(" create a RoleClass ...");
          RoleClassClass roleClassClass = pkg.getRoleClass();
          
          unitOfWork.begin();
          RoleClass roleClass = 
              roleClassClass.createRoleClass(
                  "nameValue",
                  "rcNameValue"
              );
          roleClass.setAaaa(new String[] {"aaaa", "a string values" });
          roleClass.setBbbb(new String[] {"bbbb", "b string values"});
          
          modelSegment.addRoleAbstractRoot(
              "id1",
              roleClass
          );
          unitOfWork.commit();

          
          System.out.println(" create RoleTypes needed ...");
        try {
              unitOfWork.begin();
            RoleClassRoleARoleTypeClass roleARoleTypeClass =
                pkg.getRoleClassRoleARoleType();

            System.out.println("    ra1...");
            modelSegment.addAbstractRootRoleType(
                "ra1",
                roleARoleTypeClass.createRoleClassRoleARoleType());
            // just for fun, create a second RoleType
            System.out.println("    ra2...");
            modelSegment.addAbstractRootRoleType(
                "ra2",
                roleARoleTypeClass.createRoleClassRoleARoleType());

            RoleClassRoleARoleARoleTypeClass roleARoleARoleTypeClass =
                pkg.getRoleClassRoleARoleARoleType();
            System.out.println("    rara1...");
            RoleClassRoleARoleARoleType roleClassRoleARoleARoleType = roleARoleARoleTypeClass.createRoleClassRoleARoleARoleType();
            roleClassRoleARoleARoleType.setCoreRole("ra1");
            modelSegment.addAbstractRootRoleType(
                "rara1",
                roleClassRoleARoleARoleType
            );

            System.out.println("    rara2...");
            roleClassRoleARoleARoleType = roleARoleARoleTypeClass.createRoleClassRoleARoleARoleType();
            roleClassRoleARoleARoleType.setCoreRole("ra2");
            modelSegment.addAbstractRootRoleType(
                "rara2",
                roleClassRoleARoleARoleType
            );
            unitOfWork.commit();

//      } catch (JmiServiceException je) {
        } catch (Exception je) {
            if (isDuplicateException(je)) {
               if(unitOfWork.isActive()) unitOfWork.rollback();
            } else {
                throw je;
            }
        }
         
          System.out.println(" add a role instance to roleClass...");
          unitOfWork.begin();
          RoleClassRoleAClass roleAClass = 
              pkg.getRoleClassRoleA();
          
          RoleClassRoleA roleA = 
              roleAClass.extendRoleClass(roleClass,"rcraNameValue" );
          roleA.setDddd(new String[] {"dddd", "dValue"});
          roleA.setIdent("ident8");
          
          roleClass.addRole("ra1", roleA);
          unitOfWork.commit();

          System.out.println(" add a role instance to roleA ...");
          unitOfWork.begin();
          RoleClassRoleARoleAClass roleARoleAClass = 
              pkg.getRoleClassRoleARoleA();
          
          RoleClassRoleARoleA roleARoleA = 
              roleARoleAClass.extendRoleClassRoleA(
                  roleA,  "rcraraNameValue" );
          roleARoleA.setGggg(new String[] {"gggg", "gValue"});
          
          roleA.addRole("rara1", roleARoleA);
          unitOfWork.commit();
          
          System.out.println(" add a second role instance to roleA ...");
          unitOfWork.begin();
          RoleClassRoleARoleA roleARoleA2 = 
              roleARoleAClass.extendRoleClassRoleA(
                  roleA,  "rcraraNameValue2");
          roleARoleA.setGggg(new String[] {"gggg", "gValue2"});

          // this should go wrong!!!!!
          // xxxx
          System.out.println(" create RoleClassFree ...");
          RoleClassFreeClass freeClass = pkg.getRoleClassFree();
          
          RoleClassFree free = freeClass.createRoleClassFree();
          free.setAaaa(new String[] {"aaaa", "aValue free"});
          free.setName("free name");
          
          roleARoleA.addRoleClassFree("free", free);
          unitOfWork.commit();

          System.out.println(" create RoleClassFree to second roleARoleA...");
          unitOfWork.begin();
          RoleClassFree free2 = freeClass.createRoleClassFree();
          free2.setAaaa(new String[] {"aaaa", "aValue free 2"});
          free2.setName("free name 2");

          RoleClassFree free3 = freeClass.createRoleClassFree();
          free3.setAaaa(new String[] {"aaaa", "aValue free 3"});
          free3.setName("free name 3");
          
          roleARoleA2.addRoleClassFree("free2", free2);
          roleARoleA2.addRoleClassFree("free3", free3);
          unitOfWork.commit();
                     
          System.out.println(" now get RoleClassFree of first...");
          // now try to get it
          unitOfWork.begin();
          RoleClassFree freeGet = roleARoleA.getRoleClassFree("free");

          assertTrue("expected to get the object!",
              freeGet != null);
              
          assertTrue("RoleFree gotten differs from saved.",
              freeGet.getAaaa(0).equals(free.getAaaa(0)) &&
              freeGet.getAaaa(1).equals(free.getAaaa(1)) &&
              freeGet.getName().equals(free.getName()));
          unitOfWork.commit();
          
          System.out.println(" now try to find RoleClassFree of first...");
          // now try to find it again.
          RoleClassFreeQuery filter = pkg.createRoleClassFreeQuery();
          
          filter.thereExistsAaaa().equalTo("aaaa");
          
          
          // List findings = roleARoleA.getRoleClassFree(filter);
          unitOfWork.begin();            
          Container findings = (Container) roleARoleA.getRoleClassFree();
          findings = findings.subSet(filter);
          
          assertTrue("expected 1 RoleFree children, got: " + findings.size(),
              findings.size() == 1);
          
          Iterator iter = findings.iterator();
          
          RoleClassFree freeFind = (RoleClassFree) iter.next();
                               
          assertTrue("RoleFree found differs from saved.",
              freeFind.getAaaa(0).equals(free.getAaaa(0)) &&
              freeFind.getAaaa(1).equals(free.getAaaa(1)) &&
              freeFind.getName().equals(free.getName()));
          unitOfWork.commit();
                  
      }
      catch (Exception se) {
          showException(se);
          throw se;
      } 
  }
    
  //---------------------------------------------------------------------------
  // Variables    
  //---------------------------------------------------------------------------    
  static private boolean deployed = false;
  private static Dataprovider_1_0 connection = null;
  private static boolean cleanDb = false; // clean db immediately. use doCleanDB()
  private static Path rootSegment = null;
  private static Path[] PROVIDER_DEPLOYMENT_UNITS = new Path[]{
    new Path("xri:@openmdx:org.openmdx.deployment1/provider/org:openmdx/segment/org:openmdx:test/configuration/junit/domain/apps/deploymentUnit/testrolejmi")
  };
  private static Path[] CONNECTOR_DEPLOYMENT_UNITS = new Path[]{
    new Path("xri:@openmdx:org.openmdx.deployment1/provider/org:openmdx/segment/org:openmdx:test/configuration/junit/domain/apps/deploymentUnit/connectors")
  };     

}

//--- End of File -----------------------------------------------------------
