/*
 * ====================================================================
 * Description: Date State Views 
 * Revision:    $Revision: 1.1 $
 * Owner:       OMEX AG, Switzerland, http://www.omex.ch
 * Date:        $Date: 2007/12/13 09:19:16 $
 * ====================================================================
 *
 * This software is published under the BSD license as listed below.
 * 
 * Copyright (c) 2007, OMEX AG, Switzerland
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * 
 * * Neither the name of the openMDX team nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * ------------------
 * 
 * This product includes software developed by other organizations as
 * listed in the NOTICE file.
 */
package org.openmdx.compatibility.state1.view;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

import javax.jmi.reflect.RefObject;
import javax.jmi.reflect.RefPackage;
import javax.resource.cci.InteractionSpec;
import javax.xml.datatype.XMLGregorianCalendar;

import org.openmdx.base.accessor.generic.cci.Object_1_0;
import org.openmdx.base.accessor.generic.spi.ViewContainer_1_0;
import org.openmdx.base.accessor.generic.spi.ViewObject_1_0;
import org.openmdx.base.accessor.jmi.cci.JmiServiceException;
import org.openmdx.base.accessor.jmi.cci.RefClass_1_0;
import org.openmdx.base.accessor.jmi.cci.RefObject_1_0;
import org.openmdx.base.accessor.jmi.cci.RefPackageFactory_1_1;
import org.openmdx.base.accessor.jmi.cci.RefPackage_1_2;
import org.openmdx.base.accessor.jmi.spi.RefContainer_1;
import org.openmdx.base.exception.ServiceException;
import org.openmdx.compatibility.base.naming.Path;
import org.openmdx.kernel.exception.BasicException;

#if defined(OPENMDX1)
import org.openmdx.compatibility.state1.cci.DateState;
#else
import org.openmdx.compatibility.state1.jmi1.DateState;
#endif

/**
 * Date State Views
 * <p>
 * Such an API will be provided in state2 as well.
 */
public class DateStateViews {

    protected DateStateViews(
    ) {
        // Avoid instantiation 
    }

    
    /**
     * Tells whether a propagation event may override valid states by default.
     */
    protected static final boolean OVERRIDE_DEFAULT = true;

    private static final RefObject getView(
        RefPackageFactory_1_1 refPackageFactory,
        Object_1_0 state,
        InteractionSpec viewContext
    ) throws ServiceException{
        RefPackage_1_2 viewPackage = refPackageFactory.getRefPackage(
            viewContext
        );  
        return viewPackage.refClass(
            state.objGetClass()
        ).refCreateInstance(
            Collections.singletonList(DateStateContexts.getStatedObject(state))
        );
    }
        
    /**
     * Create a view for a given object
     * 
     * @param _refObject
     * @param viewContext
     * @param clone 
     * @return
     */
    private static final RefObject getView(
        RefObject _refObject,
        DateStateContext viewContext, 
        boolean clone
    ){
        if(_refObject == null) {
            return null;
        } else {
            RefPackageFactory_1_1 refPackage;
            RefObject_1_0 refObject;
            try {
                refPackage = (RefPackageFactory_1_1) _refObject.refOutermostPackage();
                refObject = (RefObject_1_0) _refObject;
            } catch (ClassCastException exception) {
                throw (ClassCastException) new IllegalArgumentException (
                    "Either the object class " + _refObject.getClass().getName() + 
                    " or root package class " + _refObject.refOutermostPackage().getClass().getName() + 
                    " does not support views"
                ).initCause(
                    exception
                );
            }
            if(!refObject.refIsPersistent()) throw new IllegalArgumentException(
                "One can create views for persistent objects only"
            );
            try {
                RefPackage_1_2 viewPackage = refPackage.getRefPackage(
                    (InteractionSpec)viewContext
               );  
                String objectClass = refObject.refClass().refMofId();
                RefClass_1_0 viewClass = (RefClass_1_0) viewPackage.refClass(objectClass);                
                if(clone) {
                    ViewObject_1_0 source = (ViewObject_1_0) ((RefObject_1_0)_refObject).refDelegate();
                    source.cloneSourceDelegate(
                        viewContext.getValidFrom(),
                        viewContext.getValidTo()
                    );
                }
                ViewObject_1_0 viewObject = (ViewObject_1_0) viewPackage.refObjectFactory().getObject(
                    refObject.refGetPath()
                );
                viewObject.objSetClass(objectClass);
                return viewClass.refCreateInstance(
                    Collections.singletonList(viewObject)
                );
            } catch (ServiceException exception) {
                throw new JmiServiceException(exception);
            }
        }
    }

    
    //------------------------------------------------------------------------
    // Time Point Views (read-only for DateTime instances)
    //------------------------------------------------------------------------
    
    /**
     * Retrieve a view for a given validity, which is propagated
     * through navigation and applied to <code>DateState</code> instances.
     * <p>
     * Views to DateState instances are read-only, views to other objects
     * are readable and writable.
     * 
     * @param object a plain JMI object or a date view
     * @param validFor exclude all states not valid at the given date,
     * use <code>today()</code> in case of <code>null</code>
     * @param validAt exclude all states created after the given time point
     * 
     * @return a view to the given object
     */
    public static RefObject getView(
        RefObject object,
        XMLGregorianCalendar validFor,
        Date validAt
    ){
        return getView(
            object,
            DateStateContexts.newDateStateContext(
                validFor == null ? today() : validFor, 
                validAt // keep null to avoid time synchronization problems
            ), 
            false // clone
        );
    }

    /**
     * Retrieve a view for a given validity, which is propagated
     * through navigation and applied to <code>DateState</code> instances.
     * <p>
     * Views to DateState instances are read-only.
     * 
     * @param object a plain JMI object or a date state view
     * @param validFor exclude all states not valid at the given date
     * 
     * @return a view to the given object
     */
    public static RefObject getView(
        RefObject object,
        XMLGregorianCalendar validFor
    ){
        return getView(
            object,
            validFor,
            null // include all changes
        );
    }

    /**
     * Retrieve a view valid today, which is propagated
     * through navigation and applied to <code>DateState</code> instances.
     * <p>
     * Views to DateState instances are read-only.
     * 
     * @param refObject a plain JMI object or a date state view
     * 
     * @return a view to the given object
     */
    public static RefObject getView(
        RefObject refObject
    ){
        return getView(
            refObject,
            today()
        );
    }
    
    
    //------------------------------------------------------------------------
    // Time Range Views (write-only for DateTime instances)
    //------------------------------------------------------------------------
    
    /**
     * Retrieve a view for a given period.
     * <p>
     * Views to DateState instances are write-only except for stateValidFrom 
     * and stateValidTo. Attribute modification operations are propagated to 
     * all included states. Holes remain untouched.
     * 
     * @param refObject a plain JMI object or a date state view
     * @param validFrom exclude all states not valid at or after the given 
     * date unless validFrom is <code>null</code>
     * @param validTo exclude all states not valid at or before the given 
     * date unless validTo is <code>null</code>
     * 
     * @return a view to the given object
     */
    public static RefObject getViewForTimeRange(
        RefObject object,
        XMLGregorianCalendar validFrom,
        XMLGregorianCalendar validTo
    ){
        return getView(
            object,
            DateStateContexts.newDateStateContext(
                validFrom, 
                validTo
            ), 
            false // clone
        );
    }

    /**
     * Retrieve a view for the period beginning with the first valid state
     * and ending with the last valid state.
     * <p>
     * Views to DateState instances are write-only except for stateValidFrom 
     * and stateValidTo. Attribute modification operations are propagated to 
     * all included states. Holes inside the given range remain untouched.
     * 
     * @param dateState a plain JMI object or a date state view
     * 
     * @return a view covering the whole period
     */
    public static DateState getViewForLifeTime(
        DateState dateState
    ){
        List states = getStates(dateState, (XMLGregorianCalendar)null, (XMLGregorianCalendar)null);
        return states.isEmpty() ? null : (DateState)getView(
            dateState,
            DateStateContexts.newDateStateContext(
                ((DateState)states.get(0)).getStateValidFrom(),
                ((DateState)states.get(states.size()-1)).getStateValidTo()
            ), 
            false // clone
        );
    }

    /**
     * Retrieve a view for adjacent states.
     * <p>
     * Views to DateState instances are write-only except for stateValidFrom 
     * and stateValidTo. Attribute modification operations are propagated to 
     * all included states.
     * 
     * @param dateStateView the underlying date state view
     * 
     * @return a view covering the whole period
     */
    public static DateState getViewForContiguousStates(
        DateState dateStateView
    ){
        List head = getStates(dateStateView, null, dateStateView.getStateValidFrom());
        List tail = getStates(dateStateView, dateStateView.getStateValidTo(), null);
        if(head.isEmpty()) {
            //
            // dateStateView is probably invalid
            //
            return null;
        } else {
            //
            // look for begin
            //
            int from = head.size() - 1;
            while(
                from > 0 && 
                adjacent((DateState)head.get(from - 1), (DateState)head.get(from))
            ) from--;
            //
            // look for end
            //
            int to = 1;
            while(
                to < tail.size() && 
                adjacent((DateState)tail.get(to-1), (DateState)tail.get(to))
            ) to++;
            //
            // Retrieve view
            //
            return (DateState)getView(
                dateStateView,
                DateStateContexts.newDateStateContext(
                    ((DateState)head.get(from)).getStateValidFrom(),
                    ((DateState)tail.get(to-1)).getStateValidTo()
                ), 
                false // clone
            );
        }
    }
    
        
    //------------------------------------------------------------------------
    // State Propagation Views (readable and writable)
    //------------------------------------------------------------------------
    
    /**
     * Retrieve a view for a given period.
     * <p>
     * The attributes are readable and writable.
     * 
     * @param dateStateView the underlying date state view
     * @param validFrom begin of the overridden period 
     * @param validTo end of the overridden period
     * @param override tells whether it is allowed to override valid states 
     * 
     * @return a view to the given object
     */
    public static DateState getViewForInitializedState(
        DateState source,
        XMLGregorianCalendar validFrom,
        XMLGregorianCalendar validTo,
        boolean override
    ){
#if defined(OPENMDX1)
	        DateState target = getViewForPropagatedState(
	            source,
	            validFrom,
	            validTo,
	            override
	        );
	        target.refInitialize(
	            source.refClass().refCreateInstance(null)
	        );
	        return target;
#else
			throw new UnsupportedOperationException(
				"Not yet implemented for openMDX 2"
			);
#endif  
    }


	/**
     * Retrieve a view for a given period.
     * <p>
     * The attributes are readable and writable.
     * 
     * @param dateStateView the underlying date state view
     * @param validFrom begin of the overridden period 
     * @param validTo end of the overridden period
     * @param override tells whether it is allowed to override valid states 
     * 
     * @return a view to the given object
     */
    public static DateState getViewForPropagatedState(
        DateState source,
        XMLGregorianCalendar validFrom,
        XMLGregorianCalendar validTo,
        boolean override
    ){
        //
        // Compare source and view validity
        //
        boolean fromExcluded = DateStateContexts.compareValidFrom(
            source.getStateValidFrom(),
            validFrom
        ) > 0;
        boolean toExcluded = DateStateContexts.compareValidTo(
            source.getStateValidTo(),
            validTo
        ) < 0;
        //
        // Validate source
        //
        if(
            !isView(source) ||
            !isReadable(source)
        ) {
            throw new IllegalArgumentException(
                "The source should be a readable date state view object"
            );
        }            
        DateState target = (DateState) getView(
            source,
            DateStateContexts.newDateStateContext(
                validFrom, 
                validTo
            ), 
            fromExcluded || toExcluded // clone
        );
        if(
            (fromExcluded || toExcluded) &&
            !override
        ) {
            for(
                Iterator i = getStates(source, validFrom, validTo).iterator();
                i.hasNext();
            ){
                if(!i.next().equals(source)) throw new JmiServiceException(
                    new ServiceException(
                        BasicException.Code.DEFAULT_DOMAIN,
                        BasicException.Code.DUPLICATE,
                        new BasicException.Parameter[]{
                            new BasicException.Parameter("path", getPath(source)),
                            new BasicException.Parameter("validFrom", validFrom),
                            new BasicException.Parameter("validTo", validTo),
                            new BasicException.Parameter("override", Boolean.FALSE)
                        },
                        "There is another valid state in the given period"
                    )
                );
            }
        }
        return target;
    }

    /**
     * Retrieve a view for a given period, which is propagated
     * through navigation and applied to <code>DateState</code> instances.
     * <p>
     * The attributes are readable and writable.
     * 
     * @param dateStateView the underlying date state view
     * @param validFrom begin of the overridden period 
     * @param validTo end of the overridden period
     * 
     * @return a view to the given object
     */
    public static DateState getViewForPropagatedState(
        DateState dateStateView,
        XMLGregorianCalendar validFrom,
        XMLGregorianCalendar validTo
    ){
        return getViewForPropagatedState(
            dateStateView,
            validFrom,
            validTo,
            OVERRIDE_DEFAULT
        );
    }

    
    //------------------------------------------------------------------------
    // State Retrieval 
    //------------------------------------------------------------------------
    
    /**
     * Filter and order date state instances
     * 
     * @param dateStates a collection of date state instances
     * @param validFrom
     * @param validTo
     * 
     * @return a list of DateState instances
     */
    private static List order(
        Collection dateStates,
        XMLGregorianCalendar validFrom,
        XMLGregorianCalendar validTo
    ){
        SortedSet set = new TreeSet(VALID_FROM_COMPARATOR);
        for(
            Iterator i = dateStates.iterator();
            i.hasNext();
        ){
            DateState state = (DateState) i.next();
            if(
                (validFrom == null || DateStateContexts.compareValidTo(state.getStateValidTo(), validFrom) >= 0) &&
                (validTo == null || DateStateContexts.compareValidTo(state.getStateValidFrom(), validTo) <= 0)
            ) {
                set.add(state);
            }
        }
        return new ArrayList(set);
    }

    /**
     * Retrieve states 
     * 
     * @param refPackageFactory
     * @param objStates 
     * 
     * @return a collection of DateState view instances
     * 
     * @throws ServiceException  
     */
    private static Collection getStates(
        RefPackageFactory_1_1 refPackageFactory,
        Collection objStates
    ) throws ServiceException {
        Collection refStates = new ArrayList();
        for(
            Iterator i = objStates.iterator();
            i.hasNext();
        ){
            Object_1_0 object = (Object_1_0) i.next();
            refStates.add(
                getView(
                    refPackageFactory,
                    object,
                    DateStateContexts.newDateStateContext(object)
                )
            );
        }
        return refStates;
    }
    
    /**
     * Retrieve states 
     * 
     * @param referenceView the result of the parent view's getXXX() method
     * @param qualifier the object's qualifier
     * @param invalidated tells whether one looks for valid or invalid states 
     * @param deleted tells whether one non-deleted or deleted states
     * 
     * @return a collection of DateState instances
     */
    public static Collection getStates(
        Collection referenceView,
        String qualifier,
        Boolean invalidated, 
        Boolean deleted
    ){
        try {
            RefContainer_1 refContainer = (RefContainer_1) referenceView;
            ViewContainer_1_0 container = (ViewContainer_1_0) refContainer.refDelegate();
            return getStates(
                (RefPackageFactory_1_1)refContainer.refOutermostPackage(),
                container.allStates(qualifier, invalidated, deleted)
            );
        } catch (ServiceException exception) {
            throw new JmiServiceException(exception);
        } catch (ClassCastException exception) {
            throw (IllegalArgumentException) new IllegalArgumentException(
                "The reference view " + referenceView.getClass().getName() + 
                " does not support date states"
            ).initCause(
                exception
            );
        }
    }

    /**
     * Retrieve states 
     * 
     * @param referenceCollection the result of the parents getXXX() method
     * @param qualifier the object's qualifier
     * @param includeValidStates tells whether the invalidatedAt attribute may be non-null
     * @param includeInvalidStates tells whether the invalidatedAt attribute may be null
     * @param includeNonDeletedStates tells whether the <code>deleted</code> 
     * predicate may be <code>false</code>
     * @param includeDeletedStates tells whether the <code>deleted</code> 
     * predicate may be <code>true</code>
     * 
     * @return a collection of DateState instances
     */
    public static Collection getStates(
        Collection referenceCollection,
        String qualifier,
        boolean includeValidStates,
        boolean includeInvalidStates,
        boolean includeNonDeletedStates,
        boolean includeDeletedStates
    ){
        return ( 
            (includeValidStates | includeInvalidStates) &
            (includeNonDeletedStates | includeDeletedStates) 
        ) ? getStates(
            referenceCollection,
            qualifier,
            includeValidStates & includeInvalidStates ? null : Boolean.valueOf(includeInvalidStates), 
            includeNonDeletedStates & includeDeletedStates ? null : Boolean.valueOf(includeDeletedStates)
        ) : Collections.EMPTY_SET;
    }    
    
    /**
     * Retrieve non-deleted valid states
     * 
     * @param referenceCollection the result of the parents getXXX() method
     * @param qualifier the object's qualifier
     * @param validFrom include all states ending at validFrom or later
     * @param validTo include all states beginning at validTo or earlier
     * 
     * @return a list of DateState instances
     */
    public static List getStates(
        Collection referenceCollection,
        String qualifier,
        XMLGregorianCalendar validFrom,
        XMLGregorianCalendar validTo
    ){
        return order(
            getStates(referenceCollection, qualifier, Boolean.FALSE, Boolean.FALSE),
            validFrom,
            validTo
        );
    }    
    
    /**
     * Retrieve all valid states
     * 
     * @param referenceCollection the result of the parents getXXX() method
     * @param qualifier the object's qualifier
     * 
     * @return a list of DateState instances
     */
    public static List getStates(
        Collection referenceCollection,
        String qualifier
    ){
        return getStates(
            referenceCollection, 
            qualifier,
            (XMLGregorianCalendar)null,
            (XMLGregorianCalendar)null
        );
    }    
    
    /**
     * Retrieve states 
     * 
     * @param dateState a plain JMI object or a date state view
     * @param invalidated tells whether one looks for valid or invalid states 
     * @param deleted tells whether one looks for persistent or persistent-deleted states
     * 
     * @return a collection of DateState instances matching the given criteria
     */
    public static Collection getStates(
        DateState dateState,
        Boolean invalidated, 
        Boolean deleted
    ){
        if(isView(dateState)) {
            ViewObject_1_0 viewObject = (ViewObject_1_0) ((RefObject_1_0)dateState).refDelegate();
            try {
                return getStates(
                    (RefPackageFactory_1_1)dateState.refOutermostPackage(),
                    viewObject.allStates(invalidated, deleted)
                );
            } catch (ClassCastException exception) {
                throw new JmiServiceException(
                    new ServiceException(
                        exception,
                        BasicException.Code.DEFAULT_DOMAIN,
                        BasicException.Code.BAD_PARAMETER,
                        null,
                        "The date state instance does not support state access"
                    )
                );
            } catch (ServiceException exception) {
                throw new JmiServiceException(exception);
            }
        } else {
            return getStates(
                (DateState)getView(dateState),
                invalidated, 
                deleted
            );
        }
    }

    
    /**
     * Retrieve states 
     * 
     * @param dateState a plain JMI object or a date state view
     * @param includeValidStates tells whether the invalidatedAt attribute may 
     * be non-<code>null</code>
     * @param includeInvalidStates tells whether the invalidatedAt attribute 
     * may be <code>null</code>
     * @param includeNonDeletedStates tells whether the <code>deleted</code> 
     * predicate may be <code>false</code>
     * @param includeDeletedStates tells whether the <code>deleted</code> 
     * predicate may be <code>true</code>
     * 
     * @return a collection of DateState instances
     */
    public static Collection getStates(
        DateState dateState,
        boolean includeValidStates,
        boolean includeInvalidStates,
        boolean includeNonDeletedStates, 
        boolean includeDeletedStates
    ){
        return ( 
            (includeValidStates | includeInvalidStates) &
            (includeNonDeletedStates | includeDeletedStates) 
        ) ? getStates(
            dateState, 
            includeValidStates & includeInvalidStates ? null : Boolean.valueOf(includeInvalidStates), 
            includeNonDeletedStates & includeDeletedStates ? null : Boolean.valueOf(includeDeletedStates)
        ) : Collections.EMPTY_SET;
    }
    
    /**
     * Retrieve valid non-deleted states 
     * 
     * @param dateState a plain JMI object or a date state view
     * @param validFrom include all states ending at validFrom or later
     * @param validTo include all states beginning at validTo or earlier
     * 
     * @return a list of DateState instances
     */
    public static List getStates(
        DateState dateState,
        XMLGregorianCalendar validFrom,
        XMLGregorianCalendar validTo
    ){
        return order(
            getStates(dateState, Boolean.FALSE, Boolean.FALSE),
            validFrom,
            validTo
        );
    }    
    
    /**
     * Retrieve valid non-deleted states
     * 
     * @param dateState a plain JMI object or a date state view
     * 
     * @return a list of DateState instances
     */
    public static List getStates(
        DateState dateState
    ){
        return getStates(
            dateState,
            (XMLGregorianCalendar)null,
            (XMLGregorianCalendar)null
        );
    }

    
    //------------------------------------------------------------------------
    // Date State Context
    //------------------------------------------------------------------------
    
    /**
     * Retrieve the context for date state views.
     * 
     * @param refObject a plain JMI object or a date state view
     * 
     * @return the <code>DateStateContext</code> in case of a 
     * Date State View, <code>null</code> otherwise.
     */
    public static DateStateContext getContext(
        RefObject refObject
    ){
        RefPackage refPackage = refObject.refOutermostPackage();
        Object viewContext = refPackage instanceof RefPackage_1_2 ?
            ((RefPackage_1_2)refPackage).refViewContext() :
            null; 
        return viewContext instanceof DateStateContext ?
            (DateStateContext)viewContext :
            null;
    }

    /**
     * Tells whether the object is a validity aware view
     * 
     * @param refObject a plain JMI object or a date state view
     */
    public static boolean isView(
        RefObject refObject
    ){
        return getContext(refObject) != null;
    }

    /**
     * Tests whether a given object is readable
     * 
     * @param _refObject a plain JMI object or a date state view
     * 
     * @return <code>true</code> unless<ul>
     * <li><code>refObject</code> is <code>null</code> 
     * <li><code>refObject instanceof RefObject_1_0 && ((RefObject_1_0)refObject).refIsDeleted()</code> 
     * is <code>true</code> 
     * <li><code>refObject instanceof DateState && isView(refObject)</code> is <code>true</code> 
     * and the view does not refer to exactly one valid state 
     * </ul>
     */
    public static boolean isReadable(
        RefObject _refObject
    ){
        if(_refObject instanceof RefObject_1_0) {
            RefObject_1_0 reOobject = (RefObject_1_0) _refObject;
            try {
                return 
                    reOobject instanceof DateState && 
                    isView(reOobject) &&
                    reOobject.refDelegate() instanceof ViewObject_1_0 ?
                    ((ViewObject_1_0)reOobject.refDelegate()).isReadable() :
                    !reOobject.refIsDeleted();
            } catch (ServiceException exception) {
                return false;
            }
        } else {
            return _refObject != null;
        }
    }
    
    /**
     * Retrieve the current date
     * 
     * @return the current date
     */
    public static XMLGregorianCalendar today(
    ){
        return DateStateContexts.today();
    }

    /**
     * Tests whether two states are adjacent
     * 
     * @param earlier
     * @param later
     * 
     * @return <code>true</code> if two states are adjacent
     */
    private static boolean adjacent(
        DateState earlier,
        DateState later
    ){
        XMLGregorianCalendar date = (XMLGregorianCalendar) earlier.getStateValidTo().clone(); 
        date.add(DateStateContexts.ONE_DAY);
        return date.equals(later.getStateValidFrom());
    }
        

     private static Path getPath(
         RefObject refObject
     ){
         return refObject instanceof RefObject_1_0 ?
             ((RefObject_1_0)refObject).refGetPath() :
             new Path(refObject.refMofId());
     }


     /**
      * To sort the states
      */
     private static final Comparator VALID_FROM_COMPARATOR = new ValidFromComparator();


     //------------------------------------------------------------------------
     // Class ValidFromComparator
     //------------------------------------------------------------------------
     
     /**
      * Date State Valid From Comparator 
      */
     private final static class ValidFromComparator
         implements Comparator, Serializable
     {

         /**
          * Implements <code>Serializable</code>
          */
         private static final long serialVersionUID = -6816519954526341332L;
                  
         /**
          * Implements <code>Comparable</code>
          */
         public int compare(Object o1, Object o2) {
             return DateStateContexts.compareValidFrom(
                 ((DateState) o1).getStateValidFrom(),
                 ((DateState) o2).getStateValidFrom()
             );
         }
         
         /* (non-Javadoc)
          * @see java.lang.Object#equals(java.lang.Object)
          */
         public boolean equals(Object obj) {
             return obj instanceof ValidFromComparator;
         }

         /* (non-Javadoc)
          * @see java.lang.Object#hashCode()
          */
         public int hashCode() {
             return ValidFromComparator.class.hashCode();
         }

     }

}
