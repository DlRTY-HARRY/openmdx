/*
 * ==================================================================== 
 * Project: openMDX, http://www.openmdx.org
 * Description: HTML Mapper 
 * Owner: the original authors. 
 * ====================================================================
 * 
 * This software is published under the BSD license as listed below.
 * 
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * 
 * * Neither the name of the openMDX team nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * ------------------
 * 
 * This product includes or is based on software developed by other 
 * organizations as listed in the NOTICE file.
 */
package org.openmdx.application.mof.mapping.pimdoc;

import java.time.Instant;

import org.openmdx.application.mof.mapping.cci.MapperTemplate;
import org.openmdx.base.Version;
import org.openmdx.base.exception.RuntimeServiceException;
import org.openmdx.base.exception.ServiceException;
import org.openmdx.base.mof.cci.ModelElement_1_0;
import org.openmdx.base.mof.cci.Model_1_0;

import com.vladsch.flexmark.html.HtmlRenderer;
import com.vladsch.flexmark.parser.Parser;
import com.vladsch.flexmark.util.data.MutableDataSet;

/**
 * HTML Mapper
 */
abstract class HTMLMapper extends MapperTemplate {

	private HTMLMapper(Sink sink, Model_1_0 model, ModelElement_1_0 element, PIMDocConfiguration configuration) {
		super(sink.createWriter(getEntryName(element)), model);
		this.configuration = configuration;
		this.element = element;
		final MutableDataSet flexmarkOptions = FlexmarkExtensions.getOptions(configuration.getLinkTarget());
        this.annotationParser = Parser.builder(flexmarkOptions).build();
        this.annotationRenderer = HtmlRenderer.builder(flexmarkOptions).build();
	}

	protected HTMLMapper(Sink sink, Model_1_0 model, PIMDocConfiguration configuration) {
		this(sink, model, null, configuration);
	}

	protected HTMLMapper(Sink sink, ModelElement_1_0 element, PIMDocConfiguration configuration) {
		this(sink, element.getModel(), element, configuration);
	}

	protected final ModelElement_1_0 element;
	
    protected final PIMDocConfiguration configuration;
    
    private final Parser annotationParser;
    private final HtmlRenderer annotationRenderer;
    

    protected String getMapperId() {
        return getClass().getSimpleName() + " " + Version.getImplementationVersion();
    }
	
    void createArchiveEntry() {
    	fileHeader();
        this.pw.println("<html>");
        htmlHead();
        htmlBody();
        this.pw.println("</html>");
    }
    
    protected void fileHeader(
    ) {
        this.pw.println("<!DOCTYPE html>");
        fileGenerated();
    }

	protected void fileGenerated() {
		this.pw.println("<!--");
        this.pw.println(" !");
        this.pw.println(" ! Generated by " + getMapperId());
        this.pw.println(" ! Generated at " + Instant.now());
        this.pw.println(" !");
        this.pw.println(" ! GENERATED - DO NOT CHANGE MANUALLY");
        this.pw.println(" !");
        this.pw.println(" !-->");
	}

    protected void fileFooter() {
        this.pw.println("</html>");
    }

    protected void htmlHead() {
        this.pw.println("<head>");
        this.pw.println("\t<meta charset=\"utf-8\">");
        this.pw.println("\t<link rel=\"stylesheet\" href=\"" + getFileURL(MagicFile.STYLE_SHEET) + "\" />");
        htmlTitle(getTitle());
        this.pw.println("</head>");
    }

	protected void htmlTitle(final String title) {
		if(title != null) {
	        this.pw.println("\t<title>" + title + "</title>");
        }
	}
    
	/**
	 * Provide the display name (using double colon format)
	 * 
	 * @return the display name
	 * 
	 * @exception NullPointerException if element is {@code null}, e.g. for {@code IndexMapper}
	 */
    protected String getDisplayName() {
    	return element.getQualifiedName().replaceAll(":", "::");
    }
	
	/**
	 * Provide the entry name (using HTML entries)
	 * 
	 * @param element the model element used to derive the entry name
	 * 
	 * @return the entry name
	 */
    private static String getEntryName(ModelElement_1_0 element){
    	if(element == null) {
    		return MagicFile.INDEX.getFileName();
    	}
    	try {
	    	final StringBuilder entryName = new StringBuilder(
	    		element.getModel().toJavaPackageName(element, null).replace('.', '/')
	    	);
			entryName.append('/').append(element.getName());
	    	return entryName.append(".html").toString();
		} catch (ServiceException exception) {
			throw new RuntimeServiceException(exception);
    	}
    }
	
    private String getBaseURL() {
    	if(this.element == null) {
    		return "";
    	}
    	StringBuilder baseDir = new StringBuilder();
    	for(long i = element.getQualifiedName().chars().filter(HTMLMapper::isColon).count(); i > 0L; i--) {
    		baseDir.append("../");
    	}
    	return baseDir.toString();
    }

    protected String getFileURL(
    	MagicFile magicFile
    ) {
    	return getBaseURL() + magicFile.getFileName();
    }

    protected String getElementURL(
    	ModelElement_1_0 element
    ){
    	return getBaseURL() + getEntryName(element);
    }

    protected String getElementURL(
    	String qualifiedName
    ){
    	try {
			return getBaseURL() + getEntryName(this.model.getElement(qualifiedName));
		} catch (ServiceException e) {
			throw new RuntimeServiceException(e);
		}
    }
    
    protected String getDisplayName(
    	ModelElement_1_0 element
    ) {
    	String qualifiedName = element.getQualifiedName();
    	return (element.isPackageType() ? qualifiedName.substring(0, qualifiedName.lastIndexOf(':')) : qualifiedName).replace(":", "::");
    }
    
    protected void annotation(
    	ModelElement_1_0 element
    ) {
    	final String annotation  = (String)element.objGetValue("annotation");
		if(annotation != null && !annotation.isEmpty()) {
			this.pw.println("<div class=\"uml-comment\">");
			this.pw.print(annotationRenderer.render(annotationParser.parse(annotation)));		
			this.pw.println("</div>");
		}
    }
    
    private static boolean isColon(int c) {
    	return c == ':';
    }
    
	protected boolean isLocal(ModelElement_1_0 element) {
		try {
			return element.getContainer().equals(this.element.jdoGetObjectId());
		} catch (ServiceException e) {
			throw new RuntimeServiceException(e);
		} 
	}

    protected abstract String getTitle();
    
    protected abstract void htmlBody();
    
}
