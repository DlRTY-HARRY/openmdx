### Eclipse Workspace Patch 1.0
#P Core
Index: src/java/org/jpox/store/rdbms/table/AbstractTable.java
===================================================================
RCS file: /cvsroot/jpox/JPOX/Core/src/java/org/jpox/store/rdbms/table/AbstractTable.java,v
retrieving revision 1.56
diff -u -r1.56 AbstractTable.java
--- src/java/org/jpox/store/rdbms/table/AbstractTable.java	9 May 2007 09:16:01 -0000	1.56
+++ src/java/org/jpox/store/rdbms/table/AbstractTable.java	24 May 2007 15:15:40 -0000
@@ -90,6 +90,8 @@
     /** Writer to output any DDL. TODO Refactor this out and provide cleaner interface to DDL */
     protected static Writer ddlWriter = null;
 
+    protected static Writer sqlWriter = null;
+
     /** Whether we must produce complete DDL (when allowDDLOutput() && isOutputtingDdl()), or only for missing elements */
     protected static boolean completeDdl = false;
 
@@ -231,16 +233,24 @@
                 // much sense in most of the cases. (this whole block of duplicated column check, could be optional, like a pmf property)
                 throw new DuplicateColumnNameException(this.toString(), (Column)columnsByName.get(name), col);
             }
-            if (!mapping.getClass().isAssignableFrom(col.getMapping().getClass())) 
-            {
+            if (
+                !mapping.getClass().isAssignableFrom(col.getMapping().getClass()) &&
+            	!col.getMapping().getClass().isAssignableFrom(mapping.getClass())
+            ) {
                 // the mapping class must be the same (not really required, but to avoid user mistakes)
                 throw new DuplicateColumnNameException(this.toString(), (Column)columnsByName.get(name), col);
             }
-            if (!storedJavaType.equals(col.getStoredJavaType()))
-            {
-                // the stored java type must be the same (not really required, but to avoid user mistakes)
-                throw new DuplicateColumnNameException(this.toString(), (Column)columnsByName.get(name), col);
-            }
+            try {
+	            Class fieldStoredJavaTypeClass = Class.forName(storedJavaType);
+	            Class colStoredJavaTypeClass = Class.forName(col.getStoredJavaType());
+	            if (
+	                !fieldStoredJavaTypeClass.isAssignableFrom(colStoredJavaTypeClass) &&
+	                !colStoredJavaTypeClass.isAssignableFrom(fieldStoredJavaTypeClass)
+	            ) {
+	                // the stored java type must be the same (not really required, but to avoid user mistakes)
+	                throw new DuplicateColumnNameException(this.toString(), (Column)columnsByName.get(name), col);
+	            }
+            } catch(Exception e) {}
         }
 
         // Create the column, and add to the internal representation
@@ -569,6 +579,11 @@
         ddlWriter = writer;
     }
 
+    public static void setSqlWriter(Writer writer)
+    {
+        sqlWriter = writer;
+    }
+
     /**
      * Method to perform the required SQL statements.
      * @param stmts A List of statements
@@ -632,6 +647,12 @@
             }
             long startTime = System.currentTimeMillis();
             stmt.execute(stmtText);
+            try
+            {
+	            if(sqlWriter != null) {
+	                sqlWriter.write(stmtText + ";\n\n");            	
+	            }
+            } catch(IOException e) {}
             if (JPOXLogger.RDBMS_DDL.isDebugEnabled())
             {
                 JPOXLogger.RDBMS_DDL.debug(LOCALISER.msg("JDBC.Statement.ExecutionTime",(System.currentTimeMillis() - startTime)));
